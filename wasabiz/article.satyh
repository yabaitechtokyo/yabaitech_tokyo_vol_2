@import: bib
@import: ../main/book-class
@import: ../lib/code
@require: itemize
@require: proof

module Wasabiz : sig
  val article : block-text
end = struct

let-math \iff = math-char MathRel `⟺`
let-math \leftrightarrow = math-char MathRel `↔`
let-math \lnot = math-char MathOp `¬`
let-math \Coloneq = math-char MathRel `::=` % FIXME: `⩴`, (U+2A74)
let-math \lBrack = math-char MathOrd `⟦`
let-math \rBrack = math-char MathOrd `⟧`
let-math \uexists = math-char MathOrd `∃!`

let-math \Brack m = ${\lBrack #m \rBrack} % FIXME
let-math \spadesuit = math-char MathOrd `♠`

let cyr it ctx =
  read-inline (ctx |> set-font OtherScript (`cmunrm` , 1., 0.)) it
let-math \forfresh = text-in-math MathOrd (cyr (embed-string `И`))
let-math \fresh = ${\mathrel{\#}}
let-math \fv m = ${\app{\mathop{\mathrm{fv}}}{#m}}
let-math \subst m1 m2 = ${\mathord{\sqbracket{#m1/#m2}}}
let-math \Var = ${\mathrm{Var}}
let-math \Tm = ${\mathrm{Tm}}
let-math \Ty m = ${\app{\mathop{\mathrm{Ty}}}{#m}}
let-math \NF = ${\mathrm{NF}}
let-math \NE = ${\mathrm{NE}}
let-math \PVar = ${\mathrm{PVar}}
let-math \Hyp = ${\mathrm{Hyp}}
let-math \Ito = ${\mathrm{I}\mathord{\to}}
let-math \Eto = ${\mathrm{E}\mathord{\to}}
let-math \base = ${\mathbb{B}}
let-math \dom m = ${\app{\mathop{\mathrm{dom}}}{#m}}
let-math \E = ${\mathcal{E}}
let-math \W = ${\mathcal{W}}
let-math \A = ${\mathcal{A}}
let-math \PsLam = ${\Lambda_{\Ty{\base}}}
let-math \IPC = ${\mathrm{IPC}}
let-math \M = ${\mathcal{M}}
let-math \den m = ${\Brack{#m}}
let-math \H = ${\mathcal{H}}

let-math \vcenter m =
  text-in-math MathOrd (fun ctx -> (
    let ib = embed-math ctx m in
    let (w, h, d) = get-natural-metrics ib in
    let half = (h +' d) *' 0.5 in
    raise-inline (half -' h) ib
  ))

let article = '<
+chapter ?:(`wasabiz-article`) (|
    bibliography = wasabiz-bibliography;
    title = {定理証明支援系を作ろう！};
    author = {wasabiz};
    |) <
+section{目標} <
+p{
  定理証明支援系というとCoq\cite[`coq`];やIsabelle\cite[`isabelle`];のような巨大なソフトウェアを思い浮かべる人も多いかもしれません．
  しかしその実，大抵の証明支援系は核となる非常に小さい論理の上に証明を便利に記述するための殻が覆いかぶさっているにすぎません．
  そこで，今回は証明支援系をある程度の使いやすさを保証しつつもなるべく\emph{省エネ・省コード}に実装し，定理証明支援系が思ったよりもとっつきやすいものであるということを確認したいと思います．
}
+p{
  一言で定理証明支援系を作ると言っても，それがまともに使える状態であるためには核となる論理の部分を実装する以外にも以下のような機能が必要になると思われます．

  \listing{
  * パーサー
  * 束縛関係の管理
  * 型検査
  * 型推論
  * 効率的な評価器
  * タクティック言語
  }%

  以上の機能は一つ一つを取り出してみてもそれなりに実装するのが大変なものばかりです．
  そこで，今回は，これらの機能を\emph{全て実装せずに}定理証明支援系をつくります．
  と言っても，これらの機能が提供されないと言うわけではありません．
  既存の機能と理論をうまく活用してこれらを極めて小さいコードだけで実現しようというのです．
  ポイントは，\emph{定理証明支援系の上で定理証明支援系と作る}ということです．
  たとえばCoqにはパーサーも，束縛関係の管理も，型検査器も，型推論器も，効率的な評価器も，タクティック言語もすでに実装されています．
  Coqの上で定理証明支援系を作成すれば，(非常にうまくやれば)Coq自体に実装されているこれらの機能をハックして利用することができます．
  具体的には以下のような方針で，様々な言語機能の実装を\emph{サボります}．
  (ややこしいので，実装に用いる定理証明支援系を\dfn{メタ言語}，これから実装される言語を\dfn{オブジェクト言語}と呼びます．)

  \listing{
  * パーサー: DSL
  * 束縛関係の管理, 型検査, 型推論: 高階抽象構文(HOAS)
  * 効率的な評価器: 評価による正規化(NbE)
  * タクティック言語: メタ言語のタクティック言語
  }%
}
+p{
  具体的な方針は以下の通りです．
  まず，核となる論理として\emph{高階論理}と呼ばれる論理を採用します．
  高階論理は非常に強力な表現力を持ちながら極めて簡潔な構文と演繹体系を持ちます．
  よって今回の目標にはぴったりです．
  また，実装に使用する言語はLeanと呼ばれる言語です．\cite[`lean`];
  Leanは2014年ごろからMicrosoft Researchで開発されている定理証明支援系で，Coqとよく似た型理論に基づく言語です．
  LeanはCoqよりも現代的な設計と強力なメタプログラミング機構を持つ言語で，個人的にとても気に入っている言語です．
  \footnote{実はこの記事を書き始めた段階ではHaskellでの実装を予定していました．
  しかし，Haskellの型システムにはdependencyがなく，論理の推論規則が満たすべき性質を証明するのが難しかったのと，型レベルのラムダ抽象がないせいでコードが不必要に複雑化してしまうため使用をやめてしまいました．}
}
+p{
  この記事の読み方について簡単に説明します．
  この記事では定理証明支援系を作成するのにあたって必要な理論的背景とその実装の解説を交互に挟んでいます．
  もし理論方面に興味がある方は理論方面の節だけを読むのもいいでしょう．
  また，実装から読み始めたほうが理解が早いという人は実装の部分だけを読んでしまっても問題ないと思います．
  なんなら，一番最後の節から読み始めてもよいと思います．
  あと，Leanは知名度がないので今回はLeanの構文を知らない読者にもわかるよう随所にLean自体の解説も挟みました．
  具体的な目次は以下の通りです．
}
+p{
  % FIXME
  \emph{目次}
  \listing{
    * \ref-section(`ulc`);\ \ ラムダ計算
    ** \ref-subsection(`ulc`);\ \ 型無しラムダ計算
    ** \ref-subsection(`hoas`);\ \ 高階抽象構文
    ** \ref-subsection(`phoas`);\ \ 多相高階抽象構文
    * \ref-section(`stlc`);\ \ 単純型付きラムダ計算
    ** \ref-subsection(`curry-style`);\ \ Curry流の単純型付きラムダ計算
    ** \ref-subsection(`curry-vs-church`);\ \ Curry流とChurch流
    ** \ref-subsection(`church-style1`);\ \ Church流の単純型付きラムダ計算 (その1)
    ** \ref-subsection(`typeful-phoas`);\ \ 単純型付きラムダ計算の実装
    ** \ref-subsection(`nbe`);\ \ 評価による正規化
    ** \ref-subsection(`church-style2`);\ \ Church流の単純型付きラムダ計算 (その2)
    ** \ref-subsection(`judgment1`);\ \ 型判断の実装 (その1)
    ** \ref-subsection(`judgment2`);\ \ 型判断の実装 (その2)
    * \ref-section(`hol`);\ \ 高階論理
    ** \ref-subsection(`hol`);\ \ 高階論理の意味論
    ** \ref-subsection(`hol-nd`);\ \ 高階論理の演繹体系
    ** \ref-subsection(`hol-impl`);\ \ 高階論理の実装
    * \ref-section(`conclusion`);\ \ まとめ
  }
}
>

+section?:(`ulc`){ラムダ計算}<
+subsection?:(`ulc`){型無しラムダ計算} <
+p {
  この小節では\dfn{型無しラムダ計算 (untyped lambda calculus)}について復習します．
  まず，変数の無限集合${\Var}が定まっているとします．
  ${\Var}の要素は以下で${x,y,z,\cdots}で表すことにします．
  型無しラムダ計算の\dfn{項 (ラムダ項, lambda term)}は以下のBNFで帰納的に定義されます．

  \eqn(${
  M \Coloneq x \mid \lambda x. M \mid M M
  });%

  ${\lambda x.M}の形のラムダ項を\dfn{ラムダ抽象}と呼び，${MN}の形のラムダ項を\dfn{適用}と呼びます．
  適用は左結合とし，${\lambda x_1.\cdots \lambda x_n.M}を略記して${\lambda x_1,\cdots,x_n.M}と書きます．
  すべてのラムダ項からなる集合を${\Tm}と書きます．
  型無しラムダ計算の項は型付きラムダ計算の項と対比して\dfn{前項 (preterm)}と呼ばれることもあります．
}
+p{
  型無しラムダ計算でもっとも重要な概念が変数の束縛です．
  まず，ラムダ項${M}の\dfn{自由変数}の集合${\fv{M} \subseteq \Var}を以下のように構造に関する帰納法により定義します．

  \align[
  ${| \fv{x} |\coloneq \set{x} |};
  ${| \fv{\lambda x.M} |\coloneq \fv{M} \setminus \set{x} |};
  ${| \fv{MN} |\coloneq \fv{M} \cup \fv{N} |};
  ];%

  変数${x}が${\fv{M}}に属するとき，${x}は${M}について\dfn{自由である (free)}と言います．
  変数${x}が${\fv{M}}に属さない時，${x}は${M}について\dfn{自由でない (non-free)}とか\dfn{新鮮である (fresh)}と言い，${x \fresh M}と書きます．
  また，${\fv{M} = \emptyset}であるとき，${M}を\dfn{閉じている (closed)}といい，閉じていない項を\dfn{開いている (open)}といいます．
  閉じた項は\dfn{閉項}とも呼ばれます．
}
+p{
  つぎに集合${\Tm}の上に\dfn{${\alpha}同値 (${\alpha}-equivalence)}と呼ばれる同値関係を導入します．
  多くの標準的な教科書(たとえば，\cite[`Barendregt93`];)では${\alpha}同値を厳密には定義せず，いくつかの例を示して定義に代えています．
  ここでは正確な記述のために，\dfn{Nominal set theory}\cite[`GabbayP02`;`Pitts13`]; で用いられている${\alpha}同値の定義を簡単に紹介します．
  \cite[`Pitts13`];では圏論の言葉を用いてNominal set theoryが展開されていますが，ここではラムダ計算を定義するのに必要な部分だけを初等的な言葉のみで説明します．
}
+p{
  変数${x,y \in \Var}に対して写像${\paren{x\ y} : \Var \to \Var}を，${x}を${y}に，${y}を${x}に写し，それ以外の場合は入力をそのまま返すものと定義します．
  このような写像を\dfn{互換 (transposition)}と呼びます．
  互換${\pi}について，${\Tm}から${\Tm}への写像${\pi\cdot\paren{-}}を構造に関する帰納法により定義します．

  \align[
  ${| \pi\cdot x |\coloneq \app{\pi}{x} |};
  ${| \pi\cdot\paren{\lambda z.M} |\coloneq \lambda \app{\pi}{x}.\pi\cdot M |};
  ${| \pi\cdot\paren{MN} |\coloneq \paren{\pi\cdot M} \paren{\pi\cdot N} |};
  ];

  また，${\app{\pi}{x}}のことも${\pi\cdot x}と書きます．
  ${\alpha}同値性を定義するために新しい量化子${\forfresh}を導入します．

  \eqn(${
    \forfresh x \in X.\ \app{\phi}{x} \mathrel{:\iff} X \setminus \setsep{x \in X}{\app{\phi}{x}} \ \text!{is finite}
  });

  ${\forfresh x \in X.\ \app{\phi}{x}}は数学的には「有限個を除く全ての${x \in X}について${\app{\phi}{x}}が成立する (${\app{\phi}{x}} holds for all but finitely many ${x \in X})」という意味になります．
  以下では特に${X}として${\Var}を取り，${\phi}としてラムダ項についての命題を取ります．
  その場合，実は${\forfresh x.\ \app{\phi}{x}}は「新鮮な変数xについて${\app{\phi}{x}}が成り立つ」ことと同値になります．
  より正確には「${\phi}に出現する全ての項に対して新鮮な${x}について${\app{\phi}{x}}が成り立つ」ことと同値になります．
  \footnote{ここでは「『全ての』新鮮な変数xについて」なのか「『ある』新鮮な変数xについて」なのかを明示しませんでしたが，実はどちらと思って読んでも同値になることが知られています．詳しくは\cite[`Pitts13`];の定理3.9を参照してください．}
}
+p{
  最後に${\alpha}同値性を定義します．
  以下の規則に基づく帰納的定義により二項関係${\mathord{=_\alpha} \subseteq \Tm \times \Tm}を定義します．

  \math-list(${
  | \derive{| |}{ x =_\alpha x }
  | \derive{| \forfresh y.\ \paren{x\ y} \cdot M =_\alpha \paren{x'\ y} \cdot M' |}{ \lambda x.M =_\alpha \lambda x'.M' }
  | \derive{| M_1 =_\alpha M_2 | N_1 =_\alpha N_2 |}{ M_1 N_1 =_\alpha M_2 N_2 }
  |});

  実はこのような定義を採用することで${=_\alpha}は同値関係になります．
  ${M =_\alpha N}が成り立つ時，${M}と${N}は\dfn{${\alpha}同値}であると言います．
  直観的には，二つのラムダ項が${\alpha}同値であるとはそれらが同じ束縛構造を持つことを意味します．
}
+p{
  ${\alpha}同値なラムダ項はすべて同一視したほうが都合が良いので，以下ではそのようにします．
  そのために，まず${\Lambda}を商集合${\Tm/\mathord{=_\alpha}}として定義し，${\Lambda}の元${\[M\]_{=_\alpha}}を(記法を乱用して)適当な代表元${M}で表します．
  さて，この定義によれば${\Lambda}は${\Tm}と違い帰納的に定義された集合ではないので，${\Lambda}の元に対して構造に関する帰納法を回すことができません．
  しかし，${\Lambda}にはある同値な定義が存在し，それを用いれば${\Lambda}を帰納的に定義された集合と見做すことができます．\footnote{Nominal setの圏${\mathbb{Nom}}の上の始代数になります．}
  よって，${\Lambda}の元に対する帰納法が存在します．(言い換えると，${\Tm}の上の帰納法であって${\alpha}同値なものを同一視する変種が存在します．)
}
+p{
  ${\Lambda}の帰納法を説明するために\dfn{写像の自由変数}について説明します．
  ${f_1 : \Var \to \Lambda}を写像とします．
  ${f_1}が\dfn{${\fv{f_1}}を持つ}とは

  \eqn(${
    \forfresh x,x'.\ \forall y.\ \paren{x\ x'} \cdot \app{f_1}{y} = \app{f_1}{\paren{x\ x'}\cdot y}
  });

  が成り立つことであるとします．
  ${f_1}は入力に対して条件分岐を行ったり，何らかの定数ラムダ項を用いるなどして定義されます．
  そのようにして${f_1}の定義中に現れるラムダ項の自由変数のことを${f_1}自身の自由変数だと考えることにします．
  そして，そのような変数の集合を${\fv{f_1}}と書きます．
  つまり，${f_1}が${\fv{f_1}}を持つとは，${f_1}が有限個の自由変数しかもたないということに他なりません．
  (任意のラムダ項が有限個の自由変数しかもたないことと対応しています．)
  \footnote{より正確な定義は教科書を参照してください．${\fv{f_1}}は${\app{\mathrm{supp}}{f_1}}と呼ばれています．
  また，${\fv{f_1}}を持つことは\dfn{finitely supported}であると呼ばれています．}
  ${f_1}と同様に，${f_2 : \Var \times \Lambda \to \Lambda}，${f_3 : \Lambda \times \Lambda \to \Lambda}のような型の写像に対しても${\fv{f_2},\fv{f_3}}とそれらを持つかどうかを定義することができます．
}
+theorem?*?:(`alpha-structural-induction`) {
  写像${f_1 : \Var \to \Lambda}，${f_2 : \Var \times \Lambda \to \Lambda}，${f_3 : \Lambda \times \Lambda \to \Lambda}をとる．
  ${f_1,f_2,f_3}がそれぞれ${\fv{f_1},\fv{f_2},\fv{f_3}}を持つとする．
  さらに，以下の条件を満たすとする．

  \eqn(${
    x \nin \fv{f_1},\fv{f_2},\fv{f_3} \Longrightarrow \forall M.\ x \fresh \app{f_3}{x,M}
  });

  すると写像${f : \Lambda \to \Lambda}であって，
  \listing{
  * ${\app{f}{x} = \app{f_1}{x}}
  * ${\app{f}{\lambda x.M} = \app{f_2}{x, \app{f}{M}}} (ただし，${x \nin \fv{f_1},\fv{f_2},\fv{f_3}})
  * ${\app{f}{M_1 M_2} = \app{f_3}{\app{f}{M_1}, \app{f}{M_2}}}
  * ${f}は${\fv{f}}を持つ．
  }
  であるようなものがただ一つ存在する．
}
+p{
  この定理は${\Lambda}の帰納法の特殊な場合です．この定理を用いることで，ラムダ項の\dfn{置換}を定義することができます．
  変数${x}とラムダ項${M}について，以下の写像${f_1,f_2,f_3}で定理により誘導される写像を${\app{\subst{M}{x}}{-} : \Lambda \to \Lambda}と書きます．
  ${\app{\subst{M}{x}}{-}}を適用することを${x}を${M}で\dfn{置換する}と言います．

  \listing{
    * ${\app{f_1}{y} = \cases![
      (${M}, {x = y});
      (${y}, {otherwise})
    ]}
    * ${\app{f_2}{x,M} = \lambda x.M}
    * ${\app{f_3}{M_1,M_2} = M_1 M_2}
  }

  いずれもwell-definedであり，定理の条件を満たすことが簡単に確認できます．
}
+p{
  置換を用いてラムダ項の\dfn{${\beta}簡約}を定義します．二項関係${\to_\beta \subseteq \Lambda \times \Lambda}を以下のひとつの規則とみっつの合同性の規則で帰納的に定義します．

  \eqn(${ \derive{| |}{ \paren{\lambda x.M}N \to_\beta \subst{N}{x} M } });

  \math-list(${
  | \derive{| M \to_\beta M' |}{ \lambda x.M \to_\beta \lambda x.M' }
  | \derive{| M \to_\beta M' |}{ M N \to_\beta M' N }
  | \derive{| M \to_\beta M' |}{ N M \to_\beta N M' }
  |});

  ${M \to_\beta N}であるとき，${M}が${N}に\dfn{${\beta}簡約される}と言います．
  単に簡約と言った場合，${\beta}簡約のことを指します．
  一度簡約された項が再度簡約されることもあり得ます．
  ラムダ項の長さ1以上の加算列${\paren{M_i}_{i}}が全ての(有効な)${i}について${M_i \to_\beta M_{i+1}}を満たす時，その列を\dfn{簡約列}と言います．
  特に${M_0}を明示して，\dfn{${M_0}の簡約列}とも言います．
  ある簡約列が無限列であることを\dfn{発散する}と言います．
  ${M}の長さ2以上の簡約列が存在しない時，${M}を\dfn{${\beta}正規形 (${\beta}-normal form)}あるいは単に\dfn{正規形 (normal form)}と言います．
  ${\beta}正規形でない項を\dfn{${\beta}簡約基 (${\beta}-redex)}と言います．
  また，${M}の無限簡約列が存在しない時，${M}は\dfn{強正規化可能である}と言います．
  ${\to_\beta}の反射推移対称閉包を${=_\beta}を書きます．
  定義より，${=_\beta}は${\Lambda}上の同値関係です．
  ${M =_\beta N}であるとき，${M}と${N}は\dfn{${\beta}同値である}と言います．
}
>

+subsection?:(`hoas`){高階抽象構文} <
+p{
  \ref-subsection(`ulc`);でラムダ計算の形式的定義を行う際に${\alpha}変換を定義するのに苦労しました．
  これはラムダ計算をコンピュータ上で実装する場合でも同様で，束縛の構造を正しく表現するためには(特に効率よく実装するためには)それなりの量と複雑さを持つコードを書かなければなりません．
  そこでこの記事では\dfn{高階抽象構文(Higher-Order Abstract Syntax, HOAS)}と呼ばれる手法を用いてラムダ計算を実装し，\emph{束縛の構造に関するコードをほとんど記述しないまま実装します}．
  直観的には，HOASはメタ言語(今回の場合はLean(の処理系))に束縛関係の管理を外注してしまうという手法です．
  この手法ではオブジェクト言語(今回の場合はラムダ計算)は必然的にメタ言語の中でDSLとして実装されます．
  そのため，ある意味ではパーサーもメタ言語の処理系に外注していると言えます．
  結果的にですが，HOASを採用することによりオブジェクト言語のパーサーを実装する必要もなくなったことになります．
}
+p{
  さて，LeanでHOASを用いてラムダ計算を定義してみます．
  ラムダ項を表す型\code(`preterm`);は以下のように定義できます．
  \code(`inductive`); はLeanで代数的データ型を定義するための構文です．
  Leanの代数的データ型は常にHaskellでいうところのGADTの流儀で定義されます．

  \d-code(`
  inductive preterm : Type
  | lam : (preterm → preterm) → preterm
  | app : preterm → preterm → preterm
  `);

  例えば，ラムダ項${\lambda x.\lambda y. y x}は\code(`preterm`);では\code(`lam (λ x, lam (λ y, app y x))`);として表現されます．
  つまり，高階関数をうまく用いることで，メタ言語の束縛構造を利用してオブジェクト言語の束縛構造を定義しています．
  これにより，オブジェクト言語の${\alpha}同値な項はすべて同一視されます．(メタ言語の処理系が${\alpha}同値な(メタ言語の)項を同一視する機能を実装しているからです．)
  しかし，実は上に挙げたコードはLeanに与えるとエラーが出ます．

  \console(`
  hol.lean:1:0: error
  arg #1 of 'preterm.lam' has a non positive occurrence of the datatypes being declared
  `);

  これは，Leanでは停止するコードにしか型がつかないという制約によるものです．
  \code(`inductive`);を用いてデータ型を定義すると帰納法を行うためのコードが自動で生成されます．
  しかし\code(`preterm`);に対しては停止する帰納法が定義されないのです．
  これは直観的には，集合論的モデルではこのような不動点(解)であって非自明なものが存在しないためです．
  \footnote{集合${X}に関する方程式${X \cong \set{f : X \to X}}の解は一点集合のみです．
  これの数学的基礎付けについては\dfn{領域理論 (Domain theory)}の教科書が良い導入になるかも知れません．
  (たとえば\cite[`Yokouchi94`];など)}
  Leanの仕様では一般的にどのような帰納的データ型の定義が許されているかがもう少しわかりやすく定められています．
  \footnote{たとえば\cite[`LeanRef`];の4.4節．}
  一方でHaskellの型システムはLeanよりも寛容なので\code(`preterm`);のような型が実際に定義できます．
  そのため，この問題はLeanのような定理証明支援系固有の問題と言えます．
}
+p{
  さて，ここまでHOASをLeanで直接は定義できないという話をしてきましたが，実は仮に直接定義できたとしても，HOASには実用上の問題があります．
  一つ目の問題は一旦構築した項の中身を読み出せないということです．
  もう一つの問題は\code(`preterm`);型の値の中に対応するラムダ項が存在しないものがあるということです．
  まず，一つ目の問題は，例えば\code(`preterm`);型の値を通常の表記に変換する\code(`repr`);に相当する関数が定義できないということを指します．
  \footnote{なお，この問題はメタ言語が型付きの場合にのみ起こります．}
  この問題は古くから知られている問題で，\cite[`DanvyRR01`];ではこのような構文木を指して「write-only syntax」と呼んでいます．
  Write-only syntaxをreadableにするためには自由変数を表すコンストラクタを\code(`preterm`);を追加する方法が知られています．
  しかし，この方法を用いると自由変数の束縛を自前で管理する必要があり，HOASの良さであった束縛関係に関する処理を全く書く必要がないという点が失われてしまいます．
  二個目の問題も古くから知られている問題で，\cite[`Hofmann99`];などでも指摘されています．
  たとえば，${\mathrm{isapp}}なる(メタ言語の)関数を以下のように定義します

  \align[
    ${| \app{\mathrm{isapp}}{\app{\mathrm{app}}{M,N}} |\coloneq t |};
    ${| \app{\mathrm{isapp}}{\app{\mathrm{lam}}{f}} |\coloneq f |};
  ];

  ただし，${t,f}はそれぞれ真と偽をChurch encodingで表したラムダ項とします．
  もしLeanで実装する場合は以下のようなコードになるでしょう．

  \d-code(`
  def isapp : preterm → preterm
  | (lam f) := f
  | (app m₁ m₂) := t
  `);

  このとき，${\app{\mathrm{lam}}{\mathrm{isapp}}}は\code(`preterm`);型をもちかつ(メタレベルで)閉じた項であるので，
  なんらかのラムダ項を表していることが期待されますが，実際には対応するラムダ項は存在しません．
}
>

+subsection?:(`phoas`){多相高階抽象構文} <
+p{
  \ref-subsection(`hoas`);で挙げたHOASの欠点を克服する手法が\dfn{多相高階抽象構文 (Parametric HOAS, PHOAS)}と呼ばれる手法です．
  PHOASで前項を表す型を定義すると以下のようになります．

  \d-code(`
  inductive preterm (α : Type) : Type
  | var : α → preterm
  | lam : (α → preterm) → preterm
  | app : preterm → preterm → preterm
  `);%

  このように型\code(`preterm`);が型変数\code(`α`);によってパラメータ化されています．
  各コンストラクタの型シグネチャに現れている\code(`preterm`);はゼロ引数に見えますが，暗黙に\code(`α`);が適用されています．
  (これはLeanの仕様で，帰納的定義を行う際は\code(`:`);の前の引数は再帰の中で常に固定されていると解釈されます．
  この場合は，\code(`inductive preterm (α : Type) : Type`);という行の\code(`:`);の前に\code(`(α : Type)`);があるのでこの\code(`α`);は定義中で固定されています．)
  さて，このデータ型はこの\code(`α`);は通常全称量化された状態で使われます．

  \d-code(`
  def Preterm : Type 1 := Π (α : Type), preterm α
  `);%

  すると，\code(`Preterm`);はすべての閉じたラムダ項を表す型となります．
  % FIXME
  % \footnote{ただしこれをLeanの中で証明することは不可能だと思われます．
  % Coqの有名な教科書であるCPDT\cite[`CPDT`];の著者であるChlipalaはPHOASの研究者でもありますが，彼はCPDTの中でこの問題に対して「おそらく不可能だろう」と述べています．}
  \footnote{定義された変数の先頭文字が大文字になっていますが，これはLeanでは特別な意味を持ちません．}
  直観的には以下のように説明されます．
  まず\code(`var`);の引数と\code(`lam`);の引数の引数が型変数\code(`α`);になっていることに注目してください．
  \code(`α`);が全称量化されている場合，\code(`var`);の引数として取れる\code(`α`);型の値は\code(`lam`);で束縛したものに限られます．よって閉項のみが表現されます．
  さらに，\code(`α`);が全称量化されていることにより，\code(`preterm α`);型の値は\code(`var`);,\code(`lam`);,\code(`app`);のいずれかで生成されたものに限られます．
  よって，\code(`Preterm`);はすべての閉じたラムダ項を忠実に表現する型と言えます．
}
+p{
  ちなみに，細かい点ですが，Leanの型システムではTypeはpredicativeなので\code(`Preterm`);のようなdependent productは通常の型の宇宙(\code(`Type`);あるいは\code(`Type 0`);で表される)には収まらない程度に大きくなります．
  そのため\code(`Preterm`);自体の型を\code(`Type 1`);というひとつ大きな宇宙にしています．
}
+p{
  ではこの\code(`Preterm`);を用いて型無しラムダ計算が実現できるか確認します．
  \code(`Preterm`);は閉項しか表現できませんが，しばらくは開いた項を扱わないので問題ありません．
  \code(`Preterm`);は型が量化されているので，\code(`Preterm`);型の項の中身を取り出す場合は，まずどのような型で実体化するかを考える必要があります．
  たとえばdeBrujin level (有名なdeBrujin indexの変種で，束縛変数の数字が項の内側にいくにつれて増えていくようにしたもの)を使って項を文字列に変換する場合はこの\code(`α`);として自然数の型\code(`ℕ`);を採用します．

  \d-code(`
  def preterm.repr' : preterm ℕ → ℕ → string
  | (var n) _ := repr n
  | (lam f) lv := "(λ" ++ repr lv ++ "." ++ preterm.repr' (f lv) (lv + 1) ++ ")"
  | (app m₁ m₂) lv := "(" ++ preterm.repr' m₁ lv ++ " " ++ preterm.repr' m₂ lv ++ ")"

  def preterm.repr (m : Preterm) : string :=
  preterm.repr' (m ℕ) 0
  `);

  LeanにはHaskellやCoqと同じく型クラスが用意されています．
  この定義を用いて\code(`has_repr`);型クラスのインスタンスを宣言して，値の文字列化を行う汎用関数\code(`repr`);が適用できるようにします．

  \d-code(`
  instance Preterm_has_repr : has_repr Preterm :=
  ⟨preterm.repr⟩
  `);

  ParametricでないHOASでは実現できなかった\code(`repr`);を記述することができました．
}
+p{
  では，実際にラムダ項を作成してみます．
  最も簡単な例は引数をひとつとってそれをそのまま返すラムダ項${\lambda x.x}です．
  この項はよく${i}という名前で呼ばれます．
  ${i}を\code(`Preterm`);の値として記述すると以下のようになります．

  \d-code(`
  def i : Preterm := λ α, lam (λ x, var x)
  `);%

  先ほどインスタンスを定義した\code(`repr`);を用いてこれを表示してみます．

  \d-code(`
  #eval i
  --> (λ0.0)
  `);%

  \code(`--`);はLeanの一行コメントです．\code(`-->`);以降に書いた文字列\code(`(λ0.0)`);が\code(`repr i`);の結果です．
  正しく表示できているようです．
  同様に${s}や${k}と呼ばれる以下の項も定義してみます．

  \align[
  ${| s |= \lambda x. \lambda y. \lambda z. \paren{x z} \paren{y z} |};
  ${| k |=  \lambda x. \lambda y. x |};
  ];%

  ${s}と${k}はそれらの適用による組み合わせで任意のラムダ項(に${\beta}同値な項)を表現できるという意味で非常に重要な項なのですが，ここでは特に掘り下げないことにします．

  \d-code(`
  def s : Preterm := λ α, lam (λ x, lam (λ y, lam (λ z, app (app (var x) (var z)) (app (var y) (var z)))))
  def k : Preterm := λ α, lam (λ x, lam (λ y, var x))
  `);%

  やはり\code(`repr`);を使って表示してみます．
  うまく動作しているようです．

  \d-code(`
  #eval s
  --> (λ0.(λ1.(λ2.((0 2) (1 2)))))
  #eval k
  --> (λ0.(λ1.0))
  `);%
}
+p{
  次に自然数のChurch encodingを試してみます．
  Church encodingでは自然数を以下のようなラムダ項として表現します．

  \align[
  ${| 0 |= \lambda f. \lambda x. x |}; 
  ${| 1 |= \lambda f. \lambda x. f x |};
  ${| 2 |= \lambda f. \lambda x. f \paren{f x} |};
  ${| 3 |= \lambda f. \lambda x. f \paren{f \paren{f x}} |};
  ];%

  ${4}以上の自然数に対しても同様に定義されます．
  以上のラムダ項をPHOASで記述します．

  \d-code(`
  def n₀ : Preterm := λ α, lam (λ f, lam (λ x, var x))
  def n₁ : Preterm := λ α, lam (λ f, lam (λ x, app (var f) (var x)))
  def n₂ : Preterm := λ α, lam (λ f, lam (λ x, app (var f) (app (var f) (var x))))
  def n₃ : Preterm := λ α, lam (λ f, lam (λ x, app (var f) (app (var f) (app (var f) (var x)))))
  `);%

  念のため正しく定義できているか確認します．

  \d-code(`
  #eval n₀
  --> (λ0.(λ1.1))
  #eval n₁
  --> (λ0.(λ1.(0 1)))
  #eval n₂
  --> (λ0.(λ1.(0 (0 1))))
  #eval n₃
  --> (λ0.(λ1.(0 (0 (0 1)))))
  `);%

  つぎに自然数を受け取って次の自然数を返す\code(`succ`);を定義します．

  \d-code(`
  def succ : Preterm := λ α, lam (λ n, lam (λ f, lam (λ x, app (var f) (app (app (var n) (var f)) (var x)))))
  `);%

  \code(`succ`);を使う時には2つ注意点があります．
  ひとつ目は，\code(`Preterm`);型の二つの値を受け取って適用する場合は型変数を適切に分配してやる必要があるということです．
  そこで，二つの\code(`Preterm`);を受け取ってそれらの適用を返す補助関数\code(`App`);を定義しておきます．

  \d-code(`
  def App : Preterm → Preterm → Preterm :=
  λ m₁ m₂ α, app (m₁ α) (m₂ α)
  `);

  二つ目は，(当然ですが)単に適用した項を定義しただけでは項の簡約は行われないということです．
  そのため，\code(`succ_n₀`);の結果は\code(`n₁`);とは異なります．

  \d-code(`
  def succ_n₀ : Preterm := App succ n₀

  #eval succ_n₀
  --> ((λ0.(λ1.(λ2.(1 ((0 1) 2))))) (λ0.(λ1.1)))
  `);%
}
+p{
  それでは項の簡約を定義してみます．
  ここでは簡単に定義できる並列最外簡約を実装します．
  ざっくりとした簡約ですが，これ以上細かく実装すると今回の記事の趣旨から逸脱してしまうのでこれで良しとします．

  \d-code(`
  def subst' {α} : preterm (preterm α) → preterm α
  | (var x) := x
  | (lam f) := lam (λ x, subst' (f (var x))) -- terminates!
  | (app m₁ m₂) := app (subst' m₁) (subst' m₂)

  def pbeta' {α} : preterm (preterm α) → preterm α -- parallel outermost reduction
  | (var x) := x
  | (lam f) := lam (λ x, pbeta' (f (var x)))
  | (app (lam f) m) := subst' (f (subst' m))
  | (app n m) := app (pbeta' n) (pbeta' m)

  def pbeta : Preterm → Preterm :=
  λ m α, pbeta' (m _)
  `);%

  まず，Leanの構文について説明します．
  \code(`subst'`);と\code(`pbeta'`);の定義の先頭に現れている\code(`{α}`);は\code(`{α : Type}`);の略で，これは引数\code(`α`);が暗黙の引数である(処理系により自動で適切な項が補完される)ことを指定しています．
  また，\code(`pbeta`);の定義の中に現れている\code(`_`);はプレースホルダで，Leanの処理系が適切な項を推論して補完してくれます．
  ここでは\code(`preterm α`);という項が自動的に補完されます．

  では，それぞれの定義について説明します．
  \code(`subst'`);は置換を完了させるための手続きです．
  (Parametric) HOASでは変数の置換は単なるメタレベルの適用で実現されます．
  (\code(`pbeta'`);の下から二行目を見るとわかる通り置換はLeanの関数適用です．)
  ただし適用を行うには項の型が\code(`preterm (preterm α)`);という形をしている必要があります．
  \code(`subst'`);は適用を完了させ，型を\code(`preterm α`);に平坦化します．
  細かい点ですが，Leanは\code(`subst'`);が停止することを自動で検出してくれます．
  これは実は自明ではないので，場合によっては手動で証明を書く必要があるかも知れません．
  \code(`pbeta'`);は${\paren{\lambda x. M}N}という形の項を探し，置換を行います．
  先ほど説明した通り並列最外簡約です．
  \code(`pbeta`);は型を合わせるために\code(`pbeta'`);とは別に定義しました．
}
+p{
  それでは先ほどの\code(`succ_n₀`);を簡約してみます．

  \d-code(`
  #eval succ_n₀
  --> ((λ0.(λ1.(λ2.(1 ((0 1) 2))))) (λ0.(λ1.1)))
  #eval pbeta succ_n₀
  --> (λ0.(λ1.(0 (((λ2.(λ3.3)) 0) 1))))
  #eval pbeta (pbeta succ_n₀)
  --> (λ0.(λ1.(0 ((λ2.2) 1))))
  #eval pbeta (pbeta (pbeta succ_n₀))
  --> (λ0.(λ1.(0 1)))
  #eval pbeta (pbeta (pbeta (pbeta succ_n₀)))
  --> (λ0.(λ1.(0 1)))
  `);%

  うまく動いていますね．
  これだけでも十分遊べますが，今回の趣旨から逸れてしまうのでほどほどにしておきます．
}
+p{
  最後に発散する項が記述できることを確認しておわります．

  \d-code(`
  def ω : Preterm := λ α, lam (λ x, app (var x) (var x))
  def Ω : Preterm := App ω ω
  `);%

  \code(`Ω`);は${\paren{\lambda x. x x} \paren{\lambda x. x x}}という項を表しています．
  この項は簡約しても結果が自分自身となるクワインと呼ばれる種類の項の一つです．
  実際に簡約して結果が\code(`Ω`);となることを確認します．

  \d-code(`
  #eval Ω
  --> ((λ0.(0 0)) (λ0.(0 0)))
  #eval pbeta Ω
  --> ((λ0.(0 0)) (λ0.(0 0)))
  `);
}
>
>

+section?:(`stlc`){単純型付きラムダ計算} <
+p{
  \ref-section(`ulc`);では型のないラムダ計算を扱いました．
  一方で，ラムダ計算を論理学的に用いようとする場合，\emph{型付きのラムダ計算}を考えることになります．
  特に，この記事の目標である高階論理では\dfn{単純型付きラムダ計算 (Simply-typed lambda calculus, STLC)}が使われます．
  そのためにまず単純型付きラムダ計算について復習します．
  型付きラムダ計算の定義には\dfn{Curry流 (Curry-style)}と\dfn{Church流 (Church-style)}と呼ばれる二種類の流儀があります．
  \footnote{あるいは，\dfn{暗黙的型付け (implicit typing)}と\dfn{明示的型付け (explicit typing)}とも呼ばれます．\cite[`HagiyaN07`];
  \dfn{extrinsic}と\dfn{intrinsic}という用語が使われることもあります．}
  どちらも基本的なアイデアや直観は同じですが技術的には異なるやり方で導入されます．
  Curry流は\ref-section(`ulc`);で登場した型無しラムダ計算を元に定義されるので，まずはCurry流での定義を紹介します．
  その後，Church流での定義を紹介します．
  あとで詳しく話しますが，今回実装するのはChurch流の型付きラムダ計算です．
}
+subsection?:(`curry-style`){Curry流の単純型付きラムダ計算} <
+p{
  Curry流の単純型付きラムダ計算を定義します．
  まず，\dfn{基底型}の空でない集合${\base}を固定します．
  そして，\dfn{型}の集合${\Ty{\base}}を以下の規則により帰納的に定義します．

  \math-list(${
  | \derive{| \tau \in \base |}{ \tau \in \Ty{\base} }
  | \derive{| \tau \in \Ty{\base} | \sigma \in \Ty{\base} |}{ \tau \to \sigma \in \Ty{\base} }
  |});

  ${\tau \to \sigma}の形の型を${\tau}から${\sigma}への\dfn{関数型}と呼びます．
  \dfn{型環境 (type environment)}は${\Var}から${\Ty{\base}}への部分関数で定義域が有限であるものと定義します．
  型環境${\Gamma}について，その定義域が${\set{x_1,\cdots,x_n}}のとき，${\Gamma}を${x_1 : \app{\Gamma}{x_1}, \cdots, x_n : \app{\Gamma}{x_n}}と書きます．
  また，${\dom{\Gamma_1} \cap \dom{\Gamma_2} = \emptyset}のとき，${\Gamma_1 \cup \Gamma_2}を${\Gamma_1, \Gamma_2}と書きます．
  すべての型環境からなる集合を${\E}で表します．
}
+p{
  三項関係${\W \subseteq \E \times \Lambda \times \Ty{\base}}を定義します．
  ${\paren{\Gamma, M, \tau} \in \W}であることを${\Gamma \vdash M : \tau}と書きます．
  また，この形の命題を${M}についての\dfn{型判断 (type judgment)}と呼びます．
  ${\W}は以下の規則により帰納的に定義されます．
  \footnote{\ref-theorem(`alpha-structural-induction`);での${\alpha}同値な項を無視した帰納法の一般的な場合を用いており，\ref-theorem(`alpha-structural-induction`);と同様の仮定を満たしていることが簡単に確認できます．}

  \math-list(${
  | \derive{| \app{\Gamma}{x} = \tau |}{ \Gamma \vdash x : \tau }
  | \derive{| x : \tau, \Gamma \vdash M : \sigma |}{ \Gamma \vdash \lambda x.M : \tau \to \sigma }
  | \derive{| \Gamma \vdash M : \tau \to \sigma | \Gamma \vdash N : \tau |}{ \Gamma \vdash M N : \sigma }
  |});

  ラムダ項${M}と型${\tau}について，適当な環境${\Gamma}が存在して${\Gamma \vdash M : \tau}であるとき，${M}は\dfn{型${\tau}を持つ (has type ${\tau})}と言います．
  また，${M}が何らかの型を持つとき${M}は\dfn{型付け可能である (typeable)}と言います．
  このとき，以下の事実が成り立ちます．
}
+theorem?*?:(`curry-prop`){
  \listing{
    * ${M =_\beta M'}のとき，${\Gamma \vdash M : \tau \iff \Gamma \vdash M' : \tau}
    * ${M}が型付け可能ならば${M}は強正規化可能．
  }
}
+p{
  型付け可能なラムダ項には${\beta}簡約と並んで有名な\dfn{${\eta}展開}という変換規則が定義されます．
  \footnote{${\eta}展開は型無しのラムダ項にも定義できますが，今回は型付きの場合しか考えません．}
  ${\eta}展開は以下の規則に加えて${\beta}簡約のときと同様の追加規則により定義されます．

  \eqn(${
    \derive{| \text!{${M} has ${\tau \to \sigma}} | x \fresh M |}{ M \to_\eta \lambda x.M x }
  });

  ${\mathord{\to_\beta} \cup \mathord{\to_\eta}}の反射推移対称閉包を${=_{\beta\eta}}と書きます．
  ${M =_{\beta\eta} N}であるとき，${M}と${N}は\dfn{${\beta\eta}同値である}と言います．
  ${\beta\eta}同値性について\ref-theorem(`curry-prop`);の前半の一般化が成り立ちます．
}
+theorem{
  \listing{
    * ${M =_{\beta\eta} M'}のとき，${\Gamma \vdash M : \tau \iff \Gamma \vdash M' : \tau}
  }
}
+p{
  しかし，\ref-theorem(`curry-prop`);の後半の一般化は成り立ちません．
  なぜなら，例えば${\lambda x.M}や${M N}のような項について(それらが適当な型を持つなら)以下のような無限簡約列が存在するからです．\cite[`JayG95`];

  \math-list(${
  | \lambda x.M \to_\eta \lambda y.\paren{\lambda x.M}y \to_\beta \lambda y.\subst{y}{x} M =_\alpha \lambda x.M
  | M N \to_\eta \paren{\lambda x. M x} N \to_\beta M N
  |});

  この問題を回避するため${\eta}展開の規則をやや変更し，新たな展開規則${\to_{\eta'}}を導入します．
  ${\to_{\eta'}}は以下のように帰納的に定義されます．

  \math-list(${|
  | \derive{| \text!{${y} has ${\tau \to \sigma}} | x \fresh y |}{ y \to_{\eta'} \lambda x.y x }
  | \derive{| \text!{${M N} has ${\tau \to \sigma}} | x \fresh M N |}{ M N \to_{\eta'} \lambda x .\paren{M N} x }
  | \derive{| M \to_{\eta'} M' |}{ \lambda x.M \to_{\eta'} \lambda x.M' }
  | \derive{| M \to_{\eta'} M' |}{ N M \to_{\eta'} N M' }
  |});

  つまり，ラムダ抽象でなくかつ適用されていない項のみ${\eta}展開を行えるという規則が${\to_{\eta'}}です．
  ${\to_{\eta'}}にも${\to_\beta}同様簡約列などの概念が定義できます．
  \footnote{${\to_{\eta'}}は項書き換え系をなさないので一部の用語はここだけの定義としておきます．}
  特に，${\eta'}正規形を\dfn{長${\eta}形 (${\eta}-long form)}と呼びます．
  ${\eta'}展開と${\beta}\emph{展開}(i.e., ${\beta}簡約の逆向き)を用いることで${\eta}展開の規則を再現できます．
  加えて，定義より${\to_{\eta'} \subseteq \to_\eta}です．
  よって${M =_{\beta\eta'} N}と${M =_{\beta\eta} N}は同値です．
  さらに${\eta'}展開に対しては\ref-theorem(`curry-prop`);の後半の一般化が成立します．
}
+theorem?*?:(`curry-prop2`){
  \listing{
    * ${M}が型付け可能ならば${M}は${\beta\eta'}強正規化可能．
  }
}
+p{
  長${\eta}${\beta}正規形を\dfn{標準形 (canonical form)}と言います．
  \ref-theorem(`curry-prop2`);より任意の項に対してその標準形が存在し\footnote{この性質を\dfn{canonicity}と言います}，しかもそれが計算可能です．
  以降では単に\dfn{正規化}といった場合標準形を計算する操作を指します．
  よって，任意の項${M,N}に対して${M =_{\beta\eta} N}は決定可能です．(${M}と${N}を正規化して結果の${\alpha}同値性を比較すればよいです．)
}
>

+subsection?:(`curry-vs-church`){Curry流とChurch流} <
+p{
  単純型付きラムダ計算をPHOASを用いて実現する方法は主に二種類あります．
}
+p{
  ひとつはラムダ項自体は型なしのままPHOASでエンコードして，それがtypeableであるという証明を持ち回るという方法です．
  依存型がある言語ならではの方法ですが，ここまで定義してきた型無しラムダ計算用のデータ型や関数をそのまま使えるという利点があります．
  一方で，毎回証明を書かなければならない上にPHOASの項がtypeableかどうかを表す述語とその証明に関連する補助関数を一式用意しなければなりません．
  これは今回の記事の動機に反します．
}
+p{
  もうひとつの方法は，型検査をメタ言語に外注してしまうことです．
  それぞれの型付きラムダ計算の項の型をLeanレベルの型に埋め込むことで，Leanの型検査器にPHOASで作成したラムダ項のオブジェクトレベルの(i.e., 今回定義しようとしているラムダ計算の)型検査を行わせてしまいます．
  実はこのテクニックはHaskellでもPhantom typeなどを用いてよく使われるものです．
  この方式であれば，Leanの型検査がパスした時点でオブジェクト言語の型検査も終わっており，型検査に関する余計な手間をかけずに済みます．
  さらにこの方式には型推論がタダで手に入るという大きな利点があります．
  Leanの型検査器に検査を任せるということは，Leanの型検査器が持つ型推論器も使えるということです．
  Leanの持つhigher-order unifierがタダで使えるので，型推論の再実装のコストやそれに伴うバグに悩まされることもありません．
  よって，今回はこちらの方法を採ります．
}
+p{
  しかし実は\ref-subsection(`curry-style`);で導入したCurry流の型付きラムダ計算は二つ目の方法を実装するのには用いることができません．
  もし一つ目の方法を採用するのであれば型無しラムダ計算を用いるのでCurry流のSTLCの技法をそのまま用いることができるのですが，二つ目の方法を採用する場合は各変数に対して型が固定されている必要があります．
  そのような型付きラムダ計算の流儀は\dfn{Church流}と呼ばれています．
  そこで，次節ではChurch流に基づく単純型付きラムダ計算の定義を紹介します．
}
>

+subsection?:(`church-style1`){Church流の単純型付きラムダ計算 (その1)} <
+p{
  Church流の単純型付きラムダ計算を定義します．
  型の集合${\Ty{\base} = \set{\tau, \sigma, \cdots}}はCurry流と同じ定義を用います．
  型無しラムダ計算と同様に変数の無限集合${\Var = \set{x,y,z,\cdots}}を固定します．
  加えて，変数に対して型を割り当てる写像${\A : \Var \to \Ty{\base}}を固定します．
  \footnote{Curry流で登場した型環境とは違い全域で定義された写像です．}
  まず，\dfn{擬項 (pseudoterm)}の集合${\PsLam}を以下の規則で帰納的に定義します．

  \math-list(${
  | \derive{| \app{\A}{x} = \tau |}{ x^\tau \in \PsLam }
  | \derive{| M \in \PsLam | \app{\A}{x} = \tau |}{ \lambda x^\tau.M \in \PsLam }
  | \derive{| M \in \PsLam | N \in \PsLam |}{ M N \in \PsLam }
  |});

  擬項の\dfn{自由変数}や\dfn{束縛}の概念は型無しラムダ計算と同様に定義されます．
  型無しラムダ計算では${\alpha}同値な項を同一視するためにかなり苦労をしましたが，今回は暗黙のうちに${\alpha}同値な項は全て同一視することとします．
}
+p{
  すべての型${\tau}に対して擬項の集合${\Lambda_\tau \subseteq \PsLam}を以下の(擬項の)構造に関する帰納法により定めます．

  \math-list(${
  | \derive{| |}{ x^\tau \in \Lambda_\tau }
  | \derive{| M \in \Lambda_\sigma |}{ \lambda x^\tau.M \in \Lambda_{\tau \to \sigma} }
  | \derive{| M \in \Lambda_{\tau \to \sigma} | N \in \Lambda_\tau |}{ M N \in \Lambda_\sigma }
  |});

  擬項${M}が${\Lambda_\tau}に属するとき${M}は\dfn{${\tau}型を持つ (has type ${\tau})}と言います．
  また擬項${M}がなんらかの型${\tau}を持つとき${M}は\dfn{正しく型付けされている (well-typed)}と言い，そのような擬項を\dfn{項 (term)}と呼びます．
  実は(擬)項${M}が型を持つときにはその型は一意に決まります．
  つまり，${M}が型${\tau}と${\sigma}を持つとき，${\tau = \sigma}です．
  \footnote{この性質を\dfn{型付けの一意性 (uniqueness of typing)}と呼びます．}
  項の中に現れる変数${x^\tau}はしばしば${x}と略して書かれます．
  また，関数型を持つ変数をしばしば${f,g,\cdots}というメタ変数で表します．
}
+p{
  Church流のラムダ計算にも置換や${\beta}簡約，${\eta}展開を定義することができます．
  また，Curry流の場合と同様の性質が成り立ちます．
  Church流では標準形を帰納法を用いたより簡潔な方法で定義できます．
  各型${\tau}ごとに集合${\NF_\tau \subseteq \Lambda_\tau}と${\NE_\tau \subseteq \Lambda_\tau}を相互再帰で定義します．

  \math-list(${
  | \derive{| M \in \NE_\tau |}{ M \in \NF_\tau }
  | \derive{| M \in \NF_\sigma |}{ \lambda x^\tau.M \in \NF_{\tau \to \sigma} }
  | \derive{| |}{ x^\tau \in \NE_\tau }
  | \derive{| M \in \NE_{\tau \to \sigma} | N \in \NF_\tau |}{ M N \in \NE_\sigma }
  |});

  すると，${\NF_\tau}は${\tau}型を持つ標準形の集合と一致します．
  また，${\NE_\tau}の元を\dfn{中立形 (neutral form)}と呼びます．
}
>

+subsection?:(`typeful-phoas`){単純型付きラムダ計算の実装} <
+p{
  単純型付きラムダ計算をPHOASを用いて実装します．
  今回用いる手法をここでは\dfn{Typeful PHOAS}と呼ぶことにします．
  また，\ref-subsection(`phoas`);での型無しのPHOASを\dfn{Typeless PHOAS}と呼ぶことにします．
  この節以降では基底型は一つだけしかないとします．
  その唯一の基底型は(高階論理の流儀で)${\iota}で表されることが通例になっています．
  \footnote{individualの頭文字です．}
}
+p{
  まず，オブジェクト言語の型を表す型\code(`type`);を定義します．

  \d-code(`
  inductive type : Type
  | base : type
  | arrow : type → type → type
  `);

  さらに，\code(`type`);型を用いて項を表す型\code(`term`);を定義します．
  \ref-subsection(`curry-style`);のChurch流のSTLCの形式的な定義とは違い，擬項を定義せず直接項を定義します．
  \code(`variable ν : type → Type`);という文が登場していますが，これは単に\code(`term`);の引数を外に書いただけで，
  \code(`inductive term (ν : type → Type) : type → Type`);の略記です．
  以降定義する関数に\code(`ν`);が登場した場合暗黙のうちに\code(`(ν : type → Type)`);という引数が追加されます．

  \d-code(`
  variable ν : type → Type

  inductive term : type → Type
  | var : Π {t}, ν t → term t
  | lam : Π {t₁ t₂}, (ν t₁ → term t₂) → term (arrow t₁ t₂)
  | app : Π {t₁ t₂}, term (arrow t₁ t₂) → term t₁ → term t₂
  `);

  Typeless PHOASでは単なる型変数\code(`α`);だった部分が\code(`type`);を受け取って型を返す関数\code(`ν`);に変化しています．
  \footnote{\ref-subsection(`curry-style`);の定義とここでの\code(`term`);の定義を見比べると\code(`ν`);が使用されているあたりに違いがあります．
  この違いがなぜ起こるのかを説明するのは容易ではないですが，そのヒントになるかもしれない研究としてHOASの圏論的解釈を紹介しておきます．
  HOASの圏論的解釈ではそれぞれの型が\dfn{前層 (presheaf)}で解釈されます．
  すると\code(`ν`);は米田埋め込みとして解釈できます．
  より詳しい議論は\cite[`Hofmann99`;`SterlingS18`];を参照してください．}
  各コンストラクタに現れる\code(`term`);という型の引数がうまく設定されているので正しく型がついた項しか作成できないようになっています．
  \footnote{素のHOASに型だけ導入することも可能です．
  今回採用している方式はHOASをParametricとTypefulの両方の面で拡張したものです．
  より詳しい議論は\cite[`Chlipala08`];を参照してください．}
}
+p{
  Typeful PHOASの場合でもTypeless PHOASと同様に\code(`ν`);を全称量化すると各\code(`t`);について\code(`t`);型を持つ全ての閉項を表す型が得られます．

  \d-code(`
  def Term (t : type) : Type 1 :=
  Π ν, term ν t
  `);
}
+p{
  それでは型付きのラムダ項をいくつか作ってみます．
  型無しラムダ計算の時にも試したChurch encodingを試します．
  まず，自然数を表すラムダ項の型を定義します．

  \d-code(`
  def nat : type := arrow (arrow base base) (arrow base base)
  `);

  型無しラムダ計算のときと同じ例(i.e., \code(`zero`);，\code(`succ`);，\code(`succ_zero`);)を記述してみます．
  実は，Leanの型推論の機能により，型無しラムダ計算の場合と全く同じコードで型付きラムダ計算の項が記述できます．
  唯一の違いは\code(`Term`);に引数が増えていることのみです．

  \d-code(`
  def zero : Term nat :=
  λ ν, lam (λ f, lam (λ x, var x))

  def succ : Term (arrow nat nat) :=
  λ ν, lam (λ n, lam (λ f, lam (λ x, app (var f) (app (app (var n) (var f)) (var x)))))

  def App : Term (arrow t₁ t₂) → Term t₁ → Term t₂ :=
  λ m₁ m₂ ν, app (m₁ ν) (m₂ ν)

  def succ_zero : Term nat :=
  App succ zero
  `);

  ただしく項が作成できていることを確認するために(詳細は掲載しませんが)\code(`Term`);に対して\code(`has_repr`);のインスタンスを定義しました．

  \d-code(`
  #eval zero
  --> (λ0.(λ1.1)) : ((ι → ι) → (ι → ι))
  #eval succ
  --> (λ0.(λ1.(λ2.(1 ((0 1) 2))))) : (((ι → ι) → (ι → ι)) → ((ι → ι) → (ι → ι)))
  #eval succ_zero 
  --> ((λ0.(λ1.(λ2.(1 ((0 1) 2))))) (λ0.(λ1.1))) : ((ι → ι) → (ι → ι))
  `);

  うまく動いているようです．
  一方で，オブジェクト言語(i.e., STLC)で型がつかない項はTypeful PHOASでは表現できません．

  \d-code(`
  -- // type error!
  -- def ω : Term _ := λ ν, lam (λ x, app (var x) (var x))
  `);
}
>

+subsection?:(`nbe`){評価による正規化} <
+p{
  この節では項の正規化を実装します．
  特に，\dfn{評価による正規化 (Normalization by Evaluation, NbE)}というテクニックを使って実装することで非常にコンパクトなコードで正規化を実装します．
  NbEについてはこの本のzeptometerによる別の記事(\ref-chapter(`zpt-article`);)に詳細が掲載されているので，テクニックの概要の説明はそちらに譲ることにします．
  代わりに，この記事ではNbEをTypeful PHOASでどのように実装するかに焦点を合わせます．
}
+p{
  NbEを実装するためにはまずオブジェクト言語の項をメタ言語の項に変換する\code(`eval`);手続きが必要です．
  \code(`eval`);は基底型の値は基底型の値に，関数型の値は(メタ言語の)関数型の値に写します．
  それを表現するためにまず\code(`eval`);の結果が動く範囲を\code(`domain`);型として定義します．
  \code(`domain`);型は\code(`term`);型と同様に\code(`ν`);に依存しているのでそれを量化した\code(`Domain`);型も用意しておきます．

  \d-code(`
  def domain : type → Type
  | base := term ν base
  | (arrow t₁ t₂) := domain t₁ → domain t₂

  def Domain (t : type) : Type 1 :=
  Π ν, domain ν t
  `);
}
+p{
  \code(`domain`);型を使えば\code(`eval`);は簡単に定義できます．
  \code(`subst`);と同じく\code(`ν`);をうまく実体化して実装します．

  \d-code(`
  def eval' : Π {t : type}, term (domain ν) t → domain ν t
  | _ (var x) := x
  | _ (lam f) := λ x, eval' (f x)
  | _ (app m₁ m₂) := (eval' m₁) (eval' m₂)

  def eval : Term t → Domain t :=
  λ m ν, eval' ν (m _)
  `);
}
+p{
  \code(`reify`);と\code(`reflect`);はほぼ黒板通りに記述できます．
  \footnote{文献によっては\code(`reify`);の終域を標準形を表す型に，\code(`reflect`);の定義域を中立形を表す型にしている場合もあります．\cite[`DanvyKP14`];
  その場合，\code(`reify`);の結果が標準形であることが自明になるというメリットがあります．}
  \footnote{
  実際には，この定義はLean version 3.4.2ではコンパイルが通りません．
  \code(`reify`);と\code(`reflect`);が停止性することをコンパイラが自動で証明できないからです．
  そこで代わりに\code(`reify`);と\code(`reflect`);を同時に一つの再帰で定義します．
  こうすればLeanはこれらが停止することを自動で発見してくれます．
  現行のLeanはこの手の自動証明にまだ改善の余地が多々あり，将来のバージョンのLeanでは改善されているかもしれません．

  \d-code(`
  def reify_reflect : Π (t : type), (domain ν t → term ν t) × (term ν t → domain ν t)
  | base := ⟨ id, id ⟩
  | (arrow t₁ t₂) :=
    let r₁ := reify_reflect t₁ in
    let r₂ := reify_reflect t₂ in
    let reify (f : domain ν t₁ → domain ν t₂) := lam (λ x, r₂.1 (f (r₁.2 (var x)))) in
    let reflect (f : term ν (arrow t₁ t₂)) := λ x, r₂.2 (app f (r₁.1 x)) in
    ⟨reify, reflect⟩

  def reify : Domain t → Term t :=
  λ x ν, (reify_reflect ν t).1 (x ν)
  `);
  }

  \d-code(`
  mutual def reify, reflect
  with reify : Π {t : type}, domain ν t → term ν t
  | base ν := ν
  | (arrow t₁ t₂) f := lam (λ x, reify (f (reflect (var x))))
  with reflect : Π {t : type}, term ν t → domain ν t
  | base m := m
  | (arrow t₁ t₂) f := λ x, reflect (app f (reify x))

  def reify : Domain t → Term t :=
  λ x ν, reify ν (x ν)
  `);
}
+p{
  \code(`eval`);と\code(`reify`);が定義できたので，正規化を行う関数\code(`normalize`);は直ちに定義できます．

  \d-code(`
  def normalize : Term t → Term t :=
  reify ∘ eval
  `);
}
+p{
  \code(`normalize`);が正しく動くことを確認します．
  \code(`zero`);を\code(`succ`);した結果が正しく正規化されてChurch encodingの形で出力されています．

  \d-code(`
  #eval normalize zero
  --> (λ0.(λ1.1)) : ((ι → ι) → (ι → ι))
  #eval normalize (App succ zero)
  --> (λ0.(λ1.(0 1))) : ((ι → ι) → (ι → ι))
  #eval normalize (App succ (App succ zero))
  --> (λ0.(λ1.(0 (0 1)))) : ((ι → ι) → (ι → ι))
  #eval normalize (App succ (App succ (App succ zero)))
  --> (λ0.(λ1.(0 (0 (0 1))))) : ((ι → ι) → (ι → ι))
  `);

  \code(`normalize`);が${\beta}簡約だけでなく${\eta}展開を行うことも確認します．

  \d-code(`
  def i : Term (arrow (arrow base base) (arrow base base)) :=
  λ ν, lam (λ f, var f)

  #eval i
  --> (λ0.0) : ((ι → ι) → (ι → ι))
  #eval normalize i
  --> (λ0.(λ1.(0 1))) : ((ι → ι) → (ι → ι))
  `);
}
+p{
  二つの項が${\beta\eta}同値であることをLeanで記号${\approx}を用いて記述できると便利です．
  そのために，型クラス\code(`setoid`);のインスタンスを作成します．
  \footnote{正確には記法\code(`≈`);は型クラス\code(`has_equiv`);のインスタンスを定義すると使用できます．
  一方で型クラス\code(`setoid`);を持つ型は自動的に\code(`has_equiv`);を持つように(標準ライブラリで)定義されています．}

  \d-code(`
  instance : setoid (Term t) :=
  ⟨inv_image eq normalize,
   inv_image.equivalence eq normalize eq.equivalence⟩
  `);

  これで，\code(`m n : Term t`);について\code(`m ≈ n`);と書くと\code(`normalize m = normalize n`);を意味するようになります．
}
+p{
  Leanで\code(`m ≈ n`);を証明するときは常に定義を展開した上で反射性を使うことが(メタ的な議論により)わかるのでそのような証明を自動化するためにタクティックを定義します．

  \d-code(``
  meta def canonicity : tactic unit :=
  `[ try { unfold has_equiv.equiv setoid.r inv_image }, try { reflexivity } ]
  ``);

  実際にこのタクティックを使用してみます．

  \d-code(`
  def one : Term (arrow (arrow base base) (arrow base base)) :=
  λ ν, lam (λ f, lam (λ x, app (var f) (var x)))

  lemma zero_eqv_zero : zero ≈ zero :=
  by canonicity

  lemma succ_zero_eqv_one : App succ zero ≈ one :=
  by canonicity
  `);

  うまく動いているようです．
}
>

+subsection?:(`church-style2`){Church流の単純型付きラムダ計算 (その2)} <
+p{
  Curry流では型付けが型判断や型環境を元に定義されました．
  同様にChurch流でも型判断や型環境を用いた定義が可能です．
  関連して，\dfn{Curry-Howard同型対応}と呼ばれる直観主義論理との対応を確認します．
  さらに，Curry流とChurch流との比較も行います．
  技術的には，この節の内容は\ref-subsection(`nbe`);で開発した正規形を計算する手続きを閉じた項から開いた項に一般化する際に(むしろそのためだけに)必要です．
}
+p{
  固定された写像${\A : \Var \to \Ty{\base}}の有限部分集合を\dfn{型環境 (type environment)}と呼びます．
  型環境全体の集合を${\E}とします．
  定義より，Church流の型環境はCurry流の型環境です．
  Church流の型環境にたいしてもCurry流の型環境と同様の記法を用います．
  三項関係${\W \subseteq \E \times \PsLam \times \Ty{\base}}を以下の規則で帰納的に定義します．
  ${\paren{\Gamma, M, \tau} \in \W}を${\Gamma \vdash M : \tau}と書き，この形の命題を\dfn{型判断 (type judgment)}と呼びます．

  \math-list(${
  | \derive{| \app{\Gamma}{x} = \tau |}{ \Gamma \vdash x^\tau : \tau }
  | \derive{| x : \tau, \Gamma \vdash M : \sigma |}{ \Gamma \vdash \lambda x^\tau.M : \tau \to \sigma }
  | \derive{| \Gamma \vdash M : \tau \to \sigma | \Gamma \vdash N : \tau |}{ \Gamma \vdash M N : \sigma }
  |});
}
+p{
  \ref-subsection(`church-style1`);での定義とここでの定義の関連はつぎの通りです．
  ${M}を任意の擬項とし，${\Gamma}を${\A}の${\fv{M}}への制限とします．
  すると${M}が${\tau}型を持つとき，型判断${\Gamma \vdash M : \tau}が成り立ちます．
  逆に，なんらかの${\Gamma}について型判断${\Gamma \vdash M : \tau}が成り立つとき，${M}は${\tau}型を持ちます．
}
+p{
  また，Curry流とChurch流は次のように関連づけられます．
  擬項を前項に送る忘却写像${\abs{\cdot} : \PsLam \to \Lambda}を構造に関する帰納法で以下のように定義します．

  \align([
    ${| \abs{x^\tau} |\coloneq x |};
    ${| \abs{\lambda x^\tau.M} |\coloneq \lambda x.\abs{M} |};
    ${| \abs{M N} |\coloneq \abs{M} \abs{N} |};
  ]);

  すると，Church流の型判断${\Gamma \vdash M : \tau}が成り立つとき，Curry流の型判断${\Gamma \vdash \abs{M} : \tau}が成り立ちます．
  逆に，Curry流の型判断${\Gamma \vdash N : \tau}が成り立つとき，${\abs{M} = N}となるようなChurch流の項${M}と型判断${\Gamma \vdash M : \tau}が成り立ちます．
}
+p{
  型判断に対する様々な操作を定義するために${\IPC^\to}という直観主義命題論理の断片を紹介します．
  型付きラムダ計算と${\IPC^\to}の自然演繹はCurry-Howard同型対応を通じて対応しており，型判断についての様々な概念は論理学の用語を用いることで簡潔に説明されます．
}
+p{
  ${\PVar = \set{P,Q,\cdots}}を\dfn{命題変数 (propositional variable)}の集合とします．
  ${\IPC^\to}における\dfn{論理式 (formula)}，あるいは単に\dfn{式}は以下のBNFで定義されます．

  \eqn(${
    \phi \Coloneq P \mid \phi \to \phi
  });

  通常であればここで論理式の意味を決定するために論理式の\dfn{解釈 (interpretation)}を定義しますが，本筋から逸れてしまうのでここでは定義しないことにします．
  代わりに，演繹体系のみを与えます．
}
+p{
  ${\IPC^\to}の演繹体系として${\IPC^\to}の自然演繹を導入します．
  ここからは証明そのものを数学的対象として扱うことに注意してください．
  \footnote{たとえば，ここまでで登場した型判断は命題でしたが，今から扱う判断は構造です．}
}
+p{
  論理式の有限集合${\Phi}と論理式${\phi}の組${\paren{\Phi,\phi}}を\dfn{仮説的判断 (hypothetical judgment)}あるいは単に\dfn{判断 (judgment)}と呼びます．
  判断${\paren{\Phi,\phi}}をしばしば${\Phi \vdash \phi}と書きます．
  また，${\set{\phi_1, \cdots, \phi_n} \vdash \phi}をしばしば${\phi_1, \cdots, \phi_n \vdash \phi}と書きます．
  判断の左辺に並ぶ論理式を\dfn{仮定 (hypothesis)}，右辺の論理式を\dfn{結論 (conclusion)}と呼びます．
  判断の有限集合${\Xi}と判断${\H}の組${\paren{\Xi,\H}}を\dfn{推論規則 (inference rule)}あるいは単に\dfn{規則 (rule)}と呼びます．
  規則${\paren{\set{\H_1, \cdots, \H_n}, \H}}をしばしば

  \eqn(${
    \derive{| \H_1 | \cdots | \H_n |}{\H}
  });

  と書きます．
  ${P}をなんらかの述語とするとき，規則の集合${\setsep{\paren{\set{\H_1, \cdots, \H_n}, \H}}{\app{P}{\H_1,\cdots,\H_n,\H}}}を\dfn{規則図式 (rule schema)}と呼び，以下のように書きます．

  \eqn(${
    \derive?:{\app{P}{\H_1,\cdots,\H_n,\H}}{|\H_1 | \cdots | \H_n|}{\H}
  });

  規則図式${\Hyp}，${\Ito}，${\Eto}を以下のように定めます．

  \math-list(${
  | \derive?:{\ \phi \in \Phi} {| |}{ \Phi \vdash \phi }
  | \derive{| \phi, \Phi \vdash \psi |}{ \Phi \vdash \phi \to \psi }
  | \derive{| \Phi \vdash \phi \to \psi | \Phi \vdash \phi |}{ \Phi \vdash \psi }
  |});

  ${\Hyp}，${\Ito}，${\Eto}の元を順に\dfn{仮定 (hypothesis)}，\dfn{${\to}導入 (${\to}-introduction)}，\dfn{${\to}除去 (${\to}-elimination)}と呼びます．  
  判断の有限集合${\Xi}と判断${\H}について，述語${\Xi \vdash \H}\footnote{判断を表す${\vdash}とは異なります．}を次の規則\footnote{ここでの規則は単なる命題です．}によって帰納的に定義します．

  \math-list(${
  | \derive{| \paren{\Xi, \H} \in \Hyp \cup \Ito \cup \Eto |}{ \Xi \vdash \H }
  | \derive{| \Xi_1 \vdash \H_1 | \cdots | \Xi_n \vdash \H_n | \H_1, \cdots, \H_n \vdash \H |}{ \Xi_1 \cup \cdots \cup \Xi_n \vdash \H }
  |});

  ${\Xi \vdash \H}が成り立つとき，規則${\paren{\Xi,\H}}は\dfn{導出可能である (derivable)}と言います．
  導出可能な規則を\dfn{派生規則 (derived rule)}とも呼びます．
  ${\paren{\emptyset, \H}}が導出可能であるとき，${\H}を\dfn{定理 (theorem)}と呼びます．
  ${\H}が定理であるとき，${\H}が\dfn{成り立つ (holds)}と言います．
  判断${\H_1, \cdots, \H_n, \H}について，全ての${i}について${\H_i}が定理ならば${\H}も定理であるとき，規則${\paren{\set{\H_1,\cdots,\H_n}, \H}}は\dfn{許容可能である (admissible)}と言います．
  導出可能な規則は許容可能です．
}
+p{
  許容可能な規則の代表例をいくつか挙げます．
  まず，以下の二つの規則は許容可能です．

  \math-list(${
  | \derive{| \Phi \vdash \phi | \phi, \Phi \vdash \psi |}{ \Phi \vdash \psi }
  | \derive{| \Phi \vdash \phi |}{ \psi, \Phi \vdash \phi }
  |});

  この二つは順に\dfn{置換 (substitution)}，\dfn{弱化 (weakening)}という名前で呼ばれる規則です．
  実は，ここまでの話は判断の左辺を仮定の集合ではなく仮定のリストとしても成り立ちます．
  その場合，以下の二つの規則が許容可能になります．

  \math-list(${
  | \derive{| \Phi \vdash \phi |}{ \app{\pi}{\Phi} \vdash \phi }
  | \derive{| \psi, \psi, \Phi \vdash \phi |}{ \psi, \Phi \vdash \phi }
  |});

  ここで，${\app{\pi}{\Phi}}は${\Phi}の中身を並べ替えたものです．
  これら二つは順に\dfn{交換 (exchange)}，\dfn{縮約 (contraction)}と呼ばれる規則です．
  交換規則と縮約規則のおかげで，仮説的判断の左辺を実質的に集合と見做すことができるため，リストとして定義しても集合として定義しても証明可能性は実質的には変わりません．

  以上の四つの規則のように特定の論理結合子について言及しない規則を\dfn{構造規則 (structural rule)}と呼びます．
  通常，単に構造規則といえば上記の4つを指します．
}
+p{
  また，${\IPC^\to}では以下の二つの規則が許容可能です．

  \math-list(${
  | \derive{| \psi, \Phi \vdash \phi |}{ \Phi \vdash \psi \to \phi }
  | \derive{| \Phi \vdash \psi \to \phi |}{ \psi, \Phi \vdash \phi }
  |});

  一つ目は${\to}導入です．
  二つ目は\dfn{演繹定理 (deduction theorem)}と呼ばれます．
  これら二つは論理結合子${\to}の特徴付けになっています．
}
+p{
  型付きラムダ計算と${\IPC^\to}の間の関係について説明します．
  ここでは${\base = \PVar}を仮定します．
  型環境をその終域に送る関数を${\abs{\cdot}}とします．
  型判断${\Gamma \vdash M : \tau}が成り立つとき，${\abs{\Gamma} \vdash \tau}が成り立ちます．
  逆に，${\Phi \vdash \tau}が成り立つとき，き適当な型環境${\Gamma}と項${M}であって${\abs{\Gamma} = \Phi}であるものが存在して，${\Gamma \vdash M : \tau}が成り立ちます．
  この事実は${\IPC^\to}の\dfn{Curry-Howard同型対応}と呼ばれています．
  また，この議論から型付きラムダ計算においても型環境をリストとしてみなすことができ，かつ置換，弱化，交換，縮約，演繹定理に相当するものが成り立つことがわかります．
  以降の文章では，型判断を表すのにそれに対応する仮説的判断を用いることがあります．
}
>

+subsection?:(`judgment1`){型判断の実装 (その1)} <
+p{
  Typeful PHOASは一見非常にコンパクトで簡潔に見えますが，開いた項がうまく扱えないという問題があります．
  その問題を解決するために\ref-subsection(`church-style2`);で定義した型判断を用います．
  型判断は開いた項を扱いやすくする良い形式化になっているためです．
  具体的には，\ref-subsection(`typeful-phoas`);で定義した項に加えて型判断を実装し，それらの間に適切な相互変換を定義することで，開いた項をうまく扱うことを試みます．
  \footnote{この問題に対する他のアプローチとして文脈様相型を持つプログラミング言語(例えばBeluga \cite[`beluga`];)を用いる手法があります．}
  先に予告しておくと，この方針は(最後の最後で)失敗します．
  (なので，この節は読み飛ばしてしまっても構いません．)
}
+p{
  型判断を表す\code(`judgment₁`);型を定義します．
  ここでは型環境を型のリストとして表現します．

  \d-code(`
  inductive judgment₁ : list type → type → Type
  | var : Π {Γ t}, t ∈' Γ → judgment₁ Γ t
  | lam : Π {Γ t₁ t₂}, judgment₁ (t₁ :: Γ) t₂ → judgment₁ Γ (arrow t₁ t₂)
  | app : Π {Γ t₁ t₂}, judgment₁ Γ (arrow t₁ t₂) → judgment₁ Γ t₁ → judgment₁ Γ t₂
  `);

  ただし，\code(`t ∈' Γ`);は以下で定義される型です．
  \footnote{Leanの標準ライブラリには\code(`mem`);によく似た\code(`list.mem`);があるのですが，\code(`Prop`);型として定義されているので今回の用途には使いづらいので\code(`Type`);型として再実装しました．}

  \d-code(``
  inductive mem : α → list α → Type -- proof relevant version
  | here : Π {x l}, mem x (x :: l)
  | there : Π {x l y}, mem x l → mem x (y :: l)

  local infix ` ∈' `:50 := mem
  ``);
}
+p{
  型付きラムダ計算の構造規則を実装してみます．
  最終的に以下の補題を証明することが目標です．
  \footnote{補題と書いていますが，後々の都合上proof relevantにしています．
  なので，\code(`lemma`);ではなく\code(`def`);を用いています．}
  それぞれの型が構造規則にちょうど対応していることがわかります．

  \d-code(`
  def xchg  : (Γ₁ ~ Γ₂) → judgment₁ Γ₁ t → judgment₁ Γ₂ t
  def weak  : judgment₁ Γ t₁ → judgment₁ (t₂ :: Γ) t₁
  def subst : judgment₁ (t₁ :: Γ) t₂ → judgment₁ Γ t₁ → judgment₁ Γ t₂
  def contr : judgment₁ (t₁ :: t₁ :: Γ) t₂ → judgment₁ (t₁ :: Γ) t₂
  `);

  ただし，\code(`Γ₁ ~ Γ₂`);は\code(`Γ₁`);と\code(`Γ₂`);がリストとして並べ替えになっていることを表しています．
  \footnote{\code(`perm`);もLeanで既に実装されたものがあるのですが，やはり\code(`Prop`);型なので\code(`Type`);として再実装しました．}

  \d-code(`
  inductive perm : list α → list α → Type
  | nil   : perm [] []
  | skip  : Π {x : α} {l₁ l₂ : list α}, perm l₁ l₂ → perm (x :: l₁) (x :: l₂)
  | swap  : Π {x y : α} {l : list α}, perm (y :: x :: l) (x :: y :: l)
  | trans : Π {l₁ l₂ l₃ : list α}, perm l₁ l₂ → perm l₂ l₃ → perm l₁ l₃

  local infix ~ := perm
  `);
}
+p{
  さきに簡単なものから実装します．
  もし置換規則が証明できていれば，縮約規則はそれを用いて直ちに定義できます．

  \d-code(`
  def contr : judgment₁ (t₁ :: t₁ :: Γ) t₂ → judgment₁ (t₁ :: Γ) t₂ :=
  λ m, subst m (var here)
  `);

  同様に，交換規則があれば弱化規則は直ちに証明できます．

  \d-code(`
  def weak : Π {Γ t₁ t₂}, judgment₁ Γ t₁ → judgment₁ (t₂ :: Γ) t₁
  | _ _ _ (var h) := var (there h)
  | _ _ _ (lam m) := lam (xchg perm.swap (weak m))
  | _ _ _ (app m₁ m₂) := app (weak m₁) (weak m₂)
  `);

  この補題は，証明木で考えると以下のような証明木の間の変換を定義しています．

  \eqn(${
    \paren{\vcenter{\derive{| \phi_1, \Gamma \vdash \phi_2 |}{ \Gamma \vdash \phi_1 \to \phi_2 }}}
    \mapsto
    \paren{\vcenter{\derive{| \derive{| \psi, \phi_1, \Gamma \vdash \phi_2 |}{ \phi_1, \psi, \Gamma \vdash \phi_2 } |}{ \psi, \Gamma \vdash \phi_1 \to \phi_2 }}}
  });
}
+p{
  交換規則についても以下の補題があれば簡単に定義できます．
  \footnote{
    ちなみに，補題の証明は以下の通りです．
    \d-code(`
    def mem_perm {t : α} : Π {Γ₁ Γ₂}, Γ₁ ~ Γ₂ → t ∈' Γ₁ → t ∈' Γ₂
    | _ _ perm.nil h := h
    | _ _ (perm.skip _) here := here
    | _ _ (perm.skip p) (there h) := there (mem_perm p h)
    | _ _ perm.swap here := there here
    | _ _ perm.swap (there here) := here
    | _ _ perm.swap (there (there h)) := there (there h)
    | _ _ (perm.trans p₁ p₂) h := mem_perm p₂ (mem_perm p₁ h)
    `);
  }

  \d-code(`
  def mem_perm : Γ₁ ~ Γ₂ → t ∈' Γ₁ → t ∈' Γ₂
  `);

  この補題は「リストの並び替えが所属関係を保つ」ことを主張しています．
  これを用いた交換規則の具体的な証明は以下のようになります．

  \d-code(`
  def xchg : Π {Γ₁ Γ₂ t}, (Γ₁ ~ Γ₂) → judgment₁ Γ₁ t → judgment₁ Γ₂ t
  | _ _ _ p (var h) := var (mem_perm p h)
  | _ _ _ p (lam m) := lam (xchg (perm.skip p) m)
  | _ _ _ p (app m₁ m₂) := app (xchg p m₁) (xchg p m₂)
  `);
}
+p{
  さて，残る最後の規則である置換規則についても，以下のように交換規則を用いることで簡単に証明できると予想されます．

  \d-code(`
  def subst : Π {Γ t₁ t₂}, judgment₁ (t₁ :: Γ) t₂ → judgment₁ Γ t₁ → judgment₁ Γ t₂
  | _ _ _ (var here) m := m
  | _ _ _ (var (there h)) m := var h
  | _ _ _ (app m₁ m₂) m := app (subst m₁ m) (subst m₂ m)
  | _ _ _ (lam m₁) m := lam (subst (xchg perm.swap m₁) (weak m))
  `);

  しかし残念ながら，実際には現行のLeanは上の定義が停止することを自動で証明できず，エラーが出てしまいます．
  そこで，やや本質的でないのですが，\code(`subst`);が停止することを証明するために型判断の\dfn{高さ (height)}という概念を導入します．

  \d-code(`
  def heightof : Π {Γ t}, judgment₁ Γ t → ℕ
  | _ _ (var h) := 1
  | _ _ (lam m) := 1 + heightof m
  | _ _ (app m₁ m₂) := 1 + max (heightof m₁) (heightof m₂)
  `);

  そして，交換規則を用いても型判断の高さが変わらないことを示します．

  \d-code(`
  lemma height_xchg_eq_height {p : Γ₁ ~ Γ₂} {m : judgment₁ Γ₁ t} : heightof (xchg p m) = heightof m
  `);

  この補題を用いて\code(`subst`);が停止することを証明したものが以下になります．
  Leanは\code(`subst`);を\dfn{well-founded recursion}により定義しようとします．
  その際に引数が減少していることを\code(`have`);を用いて明示しています．
  \code(`subst`);が実装するアルゴリズム自体は上のものと全く同じです．
  繰り返しますが，この問題はあくまで今回用いたLean処理系固有の問題で，別のバージョンや別の処理系なら最初の\code(`subst`);だけでコンパイルが通る可能性もあります．

  \d-code(``
  def subst : Π {Γ t₁ t₂}, judgment₁ (t₁ :: Γ) t₂ → judgment₁ Γ t₁ → judgment₁ Γ t₂
  | _ _ _ (var here) m := m
  | _ _ _ (var (there h)) m := var h
  | _ _ _ (app m₁ m₂) m :=
    have heightof m₁ < heightof (app m₁ m₂),
      by unfold heightof; rw add_comm;
      from lt_add_of_le_of_pos (le_max_left _ _) zero_lt_one,
    have heightof m₂ < heightof (app m₁ m₂),
      by unfold heightof; rw add_comm;
      from lt_add_of_le_of_pos (le_max_right _ _) zero_lt_one,
    app (subst m₁ m) (subst m₂ m)
  | _ _ _ (lam m₁) m :=
    have heightof (xchg perm.swap m₁) < heightof (lam m₁),
      by unfold heightof; rw height_xchg_eq_height;
      from lt_add_of_pos_of_le zero_lt_one (le_refl _),
    lam (subst (xchg perm.swap m₁) (weak m))
  using_well_founded
  { rel_tac := λ _ _, `[exact ⟨_, measure_wf (λ v, heightof v.snd.snd.snd.fst)⟩] }
  ``);
}
+p{
  論理結合子${\to}の特徴付けである演繹定理とその逆を定義します．
  といっても，ここまでの準備のおかげで非常に簡単に定義できます．
  まず，演繹定理の逆は単に${\to}の導入則と同じだったので，それをそのまま用いるだけです．

  \d-code(`
  def abs : judgment₁ (t₁ :: Γ) t₂ → judgment₁ Γ (arrow t₁ t₂) :=
  lam
  `);

  肝心の演繹定理の方は，型合わせのために\code(`weak`);を用いることにだけ注意すればすぐに定義できます．

  \d-code(`
  def antiabs : judgment₁ Γ (arrow t₁ t₂) → judgment₁ (t₁ :: Γ) t₂ :=
  λ m, app (weak m) (var here)
  `);
}
+p{
  項\code(`term`);と型判断\code(`judgment₁`);の間の相互変換を定義します．
  型判断の仮定が空の場合，項と型判断の間には直接の対応関係があります．
  そうでない場合は演繹定理を用いることで，型判断の仮定が空の場合に帰着させます．
  例えば，${\iota \to \iota, \iota \vdash \iota}という型判断を項に変換したい場合，まず型判断を演繹定理により${\vdash \iota \to \paren{\iota \to \iota} \to \iota}に変換して，それを${\iota \to \paren{\iota \to \iota} \to \iota}という型の項に変換します．
  実際の定義は以下のようになります．
  この実装では\code(`env`);という型を経由している点が非自明です．

  \d-code(`
  inductive env : list type → Type
  | nil {} : env []
  | step : Π {t Γ}, ν t → env Γ →  env (t :: Γ)

  def to_term_var : Π {Γ t}, t ∈' Γ → env ν Γ → term ν t
  | (_ :: Γ) _ here (env.step x _) := term.var x
  | (_ :: Γ) _ (there h) (env.step _ Δ) := to_term_var h Δ

  def to_term' : Π {Γ t}, judgment₁ Γ t → env ν Γ → term ν t
  | _ _ (var h) Δ := to_term_var ν h Δ
  | _ _ (lam m) Δ := term.lam (λ x, to_term' m (env.step x Δ))
  | _ _ (app m₁ m₂) Δ := term.app (to_term' m₁ Δ) (to_term' m₂ Δ)

  def to_term : judgment₁ [] t → Term t :=
  λ m ν, to_term' ν m env.nil
  `);
}
+p{
  逆に項を型判断に変換する関数は以下のような型をもつはずです．

  \d-code(`
  def to_judgment₁ : Term t → judgment₁ [] t
  `);

  しかし，残念ながらこのような関数をLeanで定義することは不可能だと思われます．
  まず，\code(`WF`);という名前の述語\footnote{ここでは命題ではなく型にしています．}を以下のように定義します．

  \d-code(`
  inductive wf : list (Σ t, ν₁ t × ν₂ t) → Π {t}, term ν₁ t → term ν₂ t → Type
  | var : Π {Γ t} {x₁ : ν₁ t} {x₂ : ν₂ t},
    ⟨t, x₁, x₂⟩ ∈' Γ → wf Γ (var x₁) (var x₂)
  | lam : Π {Γ t₁ t₂} {f₁ : ν₁ t₁ → term ν₁ t₂} {f₂ : ν₂ t₁ → term ν₂ t₂},
    (Π x₁ x₂, wf (⟨t₁, x₁, x₂⟩ :: Γ) (f₁ x₁) (f₂ x₂)) → wf Γ (lam f₁) (lam f₂)
  | app : Π {Γ t₁ t₂} {m₁ : term ν₁ (arrow t₁ t₂)} {m₂ : term ν₂ (arrow t₁ t₂)} {n₁ : term ν₁ t₁} {n₂ : term ν₂ t₁},
    wf Γ m₁ m₂ → wf Γ n₁ n₂ → wf Γ (app m₁ n₁) (app m₂ n₂)

  def WF (t : type) (m : Term t) : Type 1 :=
  Π ν₁ ν₂, wf [] (m ν₁) (m ν₂)
  `);

  \code(`wf`);は\dfn{logical relation}や\dfn{parametricity}という名前でも知られる述語です．
  \code(`WF t m`);は全ての\code(`m`);が満たしていてほしい性質です．
  実際，様々な具体的な\code(`m : Term t`);に対して\code(`WF t m`);を(Leanの中で)証明をすることができます．
  \footnote{メタ的な議論を用いれば${\forall \text!{\code(`m : Term t`);}. \text!{\code(`WF t m`); is inhabited}}が証明できると予想されています．\cite[`CPDT`];}
  もし，全ての項に対して\code(`WF t m`);が成り立つことを表す以下の項をLeanの中で証明できれば，それを用いて\code(`to_judgment₁`);を定義できます．

  \d-code(`
  def term_wf : Π t m, WF t m := ???
  `);

  \code(`term_wf`);を仮定した場合の\code(`to_judgment₁`);の定義は以下のようになるでしょう．

  \d-code(`
  def to_judgment₁_var : Π {Γ t} {x₁ : ν₁ t} {x₂ : ν₂ t}, (sigma.mk t (prod.mk x₁ x₂)) ∈' Γ → t ∈' (list.map (λ x, sigma.fst x) Γ)
  | _ _ _ _ here := here
  | _ _ _ _ (there h) := there (to_judgment₁_var h)

  def to_judgment₁' : Π {Γ t} {m₁ : term (λ x, unit) t} {m₂ : term (λ x, unit) t}, wf Γ m₁ m₂ → judgment₁ (list.map (λ x, sigma.fst x) Γ) t
  | _ _ _ _ (wf.var h) := var (to_judgment₁_var h)
  | _ _ _ _ (wf.lam f) := lam (to_judgment₁' (f () ()))
  | _ _ _ _ (wf.app m₁ m₂) := app (to_judgment₁' m₁) (to_judgment₁' m₂)

  def to_judgment₁ : Term t → judgment₁ [] t := 
  λ m, to_judgment₁' (term_wf _ m _ _)
  `);

  しかし，\code(`term_wf`);は定義できないはずです．
  ちゃんと確認したわけではないのですが，\cite[`coq-parametricity`];の手法を適応すれば，\code(`term_wf`);が定義できないことが示せるはずです．
}
>

+subsection?:(`judgment2`){型判断の実装 (その2)} <
+p{
  \ref-subsection(`judgment1`);では型判断を実装するのに項との変換がうまく定義できませんでした．
  この節では別のエンコーディングを用いて型判断を実装して，項との変換が正しく動くことを確認します．
}
+p{
  \code(`ν`);を全称量化することで自由変数を持たない項を表せたように，関数型をうまく使うことで自由変数を1つだけもつ項の型も定義することができます．

  \d-code(`
  -- // term without free variables
  def Judgment0 (t : type) := Π ν, term ν t
  -- // term with one free variable
  def Judgment1 (t₁ t₂ : type) := Π ν, ν t₁ → term ν t₂
  `);

  このアイデアをうまく用いて型判断を表す型\code(`judgment₂`);を以下のように定義できます．

  \d-code(`
  def judgment₂ : list type → type → Type :=
  λ Γ t, list.foldr (λ t α, ν t → α) (term ν t) Γ

  def Judgment₂ (Γ : list type) (t : type) : Type 1 := -- Type 1
  Π ν, judgment₂ ν Γ t
  `);

  たとえば，${\iota}と${\iota \to \iota}型の二つの自由変数を持つ${\iota}型の項は以下のような型で表されます．

  \d-code(`
  #reduce Judgment₂ [base, arrow base base] base
  --> Π ν, ν base → ν (arrow base base) → term ν base
  `);

  また，型判断${x_1 : \iota \to \iota, x_2 : \iota \vdash \lambda y^\iota.x_2 : \iota \to \iota}は以下のように\code(`term`);のコンストラクタを用いて定義されます．

  \d-code(`
  def ex2 : Judgment₂ [arrow base base, base] (arrow base base) :=
  λ ν, λ x₁ x₂, lam (λ y, var x₂)
  `);
}
+p{
  型判断の規則を定義する前に\code(`to_term`);と\code(`to_judgment₂`);が定義できることを確認します．
  じつはこれは非常に簡単です．
  \code(`Judgment₂`);の定義より，\code(`Judgment₂ [] t`);は\code(`Term t`);と全く同じ型です．
  よって，\code(`to_term`);も\code(`to_judgment₂`);も単なる恒等関数として定義すればよいです．

  \d-code(`
  def to_term : Judgment₂ [] t → Term t :=
  id

  def to_judgment₂ : Term t → Judgment₂ [] t :=
  id
  `);
}
+p{
  型判断の規則を定義します．
  最も特徴的なのは弱化です．
  簡潔に定義できます．

  \d-code(`
  def weak : Judgment₂ Γ t₂ → Judgment₂ (t₁ :: Γ) t₂ :=
  λ m ν x, m ν
  `);

  この定義を見ると，オブジェクトレベルの弱化を行うためにメタレベルの弱化を行なっていることがわかります．
  置換の定義も素直です．
  ここで\ref-section(`ulc`);で定義した\code(`subst'`);をそのまま用いています．

  \d-code(`
  def subst'' : Π {Γ}, judgment₂ (term ν) (t₁ :: Γ) t₂ → judgment₂ ν Γ t₁ → judgment₂ ν Γ t₂
  | [] m₁ m₂ := subst' ν (m₁ m₂)
  | (t :: Γ) f m := λ x, subst'' (λ x', f x' (var x)) (m x)

  def subst : Judgment₂ (t₁ :: Γ) t₂ → Judgment₂ Γ t₁ → Judgment₂ Γ t₂ :=
  λ m₁ m₂ ν, subst'' ν (m₁ _) (m₂ ν)
  `);

  型判断の定義に現れる最も基本的な三つの規則も素直に定義されます．
  \footnote{
    たとえば\code(`app`);は以下のようなコードになります．

    \d-code(`
    def app' : Π {Γ}, judgment₂ ν Γ (arrow t₁ t₂) → judgment₂ ν Γ t₁ → judgment₂ ν Γ t₂
    | [] m₁ m₂ := app m₁ m₂
    | (t :: Γ) f m := λ x, app' (f x) (m x)

    def app : Judgment₂ Γ (arrow t₁ t₂) → Judgment₂ Γ t₁ → Judgment₂ Γ t₂ :=
    λ m₁ m₂ ν, app' ν (m₁ ν) (m₂ ν)
    `);
  }

  \d-code(`
  def var : t ∈' Γ → Judgment₂ Γ t
  def lam : Judgment₂ (t₁ :: Γ) t₂ → Judgment₂ Γ (arrow t₁ t₂)
  def app : Judgment₂ Γ (arrow t₁ t₂) → Judgment₂ Γ t₁ → Judgment₂ Γ t₂
  `);

  縮約は\ref-subsection(`judgment1`);と全く同じコードで定義できます．

  \d-code(`
  def contr : Judgment₂ (t₁ :: t₁ :: Γ) t₂ → Judgment₂ (t₁ :: Γ) t₂ :=
  λ m, subst m (var here)
  `);

  交換も(ここでは省略しますが)素直に実装できます．
  演繹定理も\code(`type.foldr`);を適切に定義することで実装できます．

  \d-code(`
  def abs : Judgment₂ Γ t → Term (type.foldr Γ t)
  def antiabs : Judgment₂ [] (type.foldr Γ t) → Judgment₂ Γ t
  `);

  \code(`abs`);が定義できたことで以下のように型判断の間(つまり開いた項の間)の${\beta\eta}同値性が計算できるようになります．

  \d-code(`
  instance : setoid (Judgment₂ Γ t) :=
  ⟨inv_image eq (normalize ∘ to_term ∘ judgment₂.abs),
   inv_image.equivalence eq (normalize ∘ to_term ∘ judgment₂.abs) eq.equivalence⟩
  `);
}
>
>

+section?:(`hol`){高階論理}<
+subsection?:(`hol`){高階論理の意味論}<
+p{
  \dfn{高階論理 (Higher-order logic, HOL)}を導入します．
  高階論理と呼ばれるものには様々な変種があり確立された唯一の定義があるわけではありません．
  例えば，Churchの\emph{Simple Type Theory (STT)}\cite[`Church40`];やCoquandとHuetの\emph{Calculus of Constructions (CoC)}\cite[`CoquandH88`];が有名です．
  この節では高階論理のなかでも特に小さくわかりやすい等号に基づく定義を紹介します．
}
+p{
  高階論理の構文論を定義します．
  高階論理はChurch流の型付きラムダ計算を拡張したような構文を持ちます．
  ただし，基底型や関数型に加えて${\omicron}で表される型を持ちます．
  つまり，高階論理の型の集合は以下のBNFで表せます．

  \eqn(${
    \tau \Coloneq \iota \mid \omicron \mid \tau \to \tau
  });

  ただし，${\iota}は${\base}の元を表すとします．
  一階述語論理とのアナロジーで言えば，${\iota}が項が動く領域で，${\omicron}が命題が動く領域です．
  ${\omicron}型を持つ変数をしばしば${p,q,\cdots}というメタ変数で表します．
  高階論理の\dfn{言語 (language)}あるいは\dfn{シグニチャ (signature)}とは型で添字づけられた集合${\paren{\Sigma_\tau}_{\tau \in \Ty{\base}}}のこととします．
  以下，言語${\Sigma}を固定します．
  擬項の定義${\PsLam}を以下の規則で拡張します．

  \math-list(${
  | \derive{| c \in \Sigma_\tau |}{ c^\tau \in \PsLam }
  | \derive{| M \in \PsLam | N \in \PsLam |}{ M \doteq N \in \PsLam }
  |});

  つまり，高階論理の擬項の集合は以下のBNFで表せます．

  \eqn(${
    M \Coloneq x^\tau \mid c^\tau \mid \lambda x^\tau. M \mid M M \mid M \doteq M
  });

  項の定義${\Lambda_\tau}は以下の規則で拡張されます．

  \math-list(${
  | \derive{| c \in \Sigma_\tau |}{ c^\tau \in \Lambda_\tau }
  | \derive{| M \in \Lambda_\tau | N \in \Lambda_\tau |}{ M \doteq N \in \Lambda_\omicron }
  |});

  ${\Sigma_\tau}の要素であるような項を\dfn{定数 (constant)}と呼びます．
  ${\beta}簡約や${\eta}展開は定数や${\doteq}に対してcongruentに振る舞うとします．
  ${\omicron}型の項を\dfn{論理式 (formula)}と呼びます．
  閉じた論理式を\dfn{閉論理式 (closed formula)}あるいは\dfn{文 (sentense)}と呼びます．
  言語${\Sigma}と${\Sigma}上の文の集合${E}の組${\paren{\Sigma,E}}を\dfn{理論 (theory)}と呼びます．
  ${E}の要素を\dfn{公理 (axiom)}と呼ぶことがあります．
}
+p{
  高階論理の意味論を定義します．
  高階論理には\dfn{集合論的意味論 (set-theoretic semantics)}，\dfn{Henkin意味論 (Henkin semantics)}，\dfn{トポス意味論 (topos semantics)}など複数の意味論があります．
  ここで紹介するのはもっとも標準的な意味論である集合論的意味論です．
  \footnote{集合論的意味論は素朴で直観的なのですが，意味論として期待される性質を満たさないことが知られています．
  現代的にはトポス意味論やその一般化を用いることが良いとされているようです．
  例えば，Bauerによる投稿を\cite[`Bauer-mathoverflow`];参照してください．
  トポス意味論への入門記事としては\cite[`Uemura18`];が大変わかりやすいです．}
  ${\Omega}を${0}と${1}からなる二点集合とします．
  この記事では${0}を真，${1}を偽として扱います．
  言語${\Sigma}の\dfn{構造 (structure)}とは集合と写像の組の族${\M = \paren{D_\tau,\ \M_\tau : \Sigma_\tau \to D_\tau}_{\tau \in \Ty{\base}}}であって，

  \align[
    ${| D_\omicron |= \Omega |};
    ${| D_{\tau \to \sigma} |= \set{f : D_\tau \to D_\sigma} |}
  ];

  を満たすものとします．
  \footnote{全ての基底型${\iota}に対して${D_\iota}を決めれば残りの${D_\tau}は自動的に決まります．}
  構造${\M}についての\dfn{付値 (valuation)}とは各変数${x \in \Var}に対して${D_{\app{\A}{x}}}の要素を割り当てる写像です．
  構造${\M}による項の\dfn{解釈 (interpretation)}を型${\tau}と付値${\theta}を添字にとる写像${\den{\cdot}^\M_{\tau,\theta} : \Lambda_\tau \to D_\tau}として以下の帰納法で定めます．

  \align[
    ${| \den{x^\tau}^\M_{\tau,\theta} |\coloneq \app{\theta}{x} |};
    ${| \den{c^\tau}^\M_{\tau,\theta} |\coloneq \app{\M_\tau}{c} |};
    ${| \app{\den{\lambda x^\tau.M}^\M_{\tau\to\sigma,\theta}}{v} |\coloneq \den{M}^\M_{\sigma,\subst{v}{x} \theta} |};
    ${| \den{MN}^\M_{\sigma,\theta} |\coloneq \app{\den{M}^\M_{\tau\to\sigma,\theta}}{\den{N}^\M_{\tau,\theta}} |};
    ${| \den{M \doteq N}^\M_{\omicron,\theta} |\coloneq \cases![
      (${0}, {(${\den{M}^\M_{\tau,\theta} = \den{N}^\M_{\tau,\theta}})});
      (${1}, {otherwise})
    ] |}
  ];

  論理式${\phi}について${\den{\phi}^\M_{\omicron,\theta} = 0}が成り立つとき，${\M,\theta \vDash \phi}と書きます．
  また，任意の付値${\theta}について${\M,\theta \vDash \phi}であるとき，${\M \vDash \phi}と書きます．
  任意の構造${\M}について${\M \vDash \phi}であるとき，${\vDash \phi}と書き，${\phi}は\dfn{恒真である (valid)}と言います．
  ある構造${\M}と付値${\theta}が存在して${\M,\theta \vDash \phi}となるとき，${\phi}は\dfn{充足可能である (satisfiable)}と言います．
  ${\phi_1}と${\phi_2}を論理式とします．
  任意の構造${\M}と任意の付値${\theta}について${\den{\phi_1}^\M_{\omicron,\theta} = \den{\phi_2}^\M_{\omicron,\theta}}となるとき，${\phi_1}と${\phi_2}は\dfn{論理同値である (logically equivalent)}と言い，${\phi_1 \simeq \phi_2}と書きます．
  文の集合${E}について，任意の${E}の要素${A}が${\M \vDash A}を満たすとき，${\M}を${E}の\dfn{モデル (model)}と呼びます．
  また，理論${T = \paren{\Sigma,E}}の\dfn{モデル}とは${E}のモデルのことです．
  論理式${\phi}と文の集合${E}について，任意の${E}のモデル${\M}が${\M \vDash \phi}を満たすとき，${E \vDash \phi}と書き，${\phi}を${E}の\dfn{論理的帰結 (logical consequence)}と呼びます．
}
+p{
  高階論理の表現能力について簡単に触れます．
  高階論理が持つ論理式の構成子は${\doteq}だけです．
  これでは一見，高階論理が非常に表現力の弱い論理に見えます．
  \footnote{たとえば，論理結合子が${\land}しかない命題論理を考えると，それはかなり表現力の弱い論理であると言えるでしょう．}
  しかし，実はラムダ抽象をうまく用いることで通常用いられる種々の論理結合子を高階論理の中で定義することができます．
  たとえば，論理式${\phi_1}と${\phi_2}に対して以下のような論理式を考えます．

  \eqn(${
    \paren{\lambda f^{\omicron \to \omicron \to \omicron}. \mathop{f} \paren{f \doteq f} \paren{f \doteq f}} \doteq \paren{\lambda f^{\omicron \to \omicron \to \omicron}. \mathop{f} \phi_1 \phi_2}
  });

  この論理式を${\phi_1 \mathrel{\spadesuit} \phi_2}と書くことにします．
  すると，以下が成り立ちます．
}
+lemma{
  任意の構造${\M}と付値${\theta}について，${\M,\theta \vDash \phi_1 \mathrel{\spadesuit} \phi_2}であるとき，かつそのときに限り${\M,\theta \vDash \phi_1}かつ${\M,\theta \vDash \phi_2}
}
+p{
  よって，上で定義した${\mathrel{\spadesuit}}は通常の論理で言う論理積 (conjunction)と見なせます．
  これと同じことがより一般に直観主義論理の基本的な論理結合子\footnote{線形論理でいうところのnegativeな結合子．あるいは，圏論的意味論で右随伴によって意味が定められる結合子．}について成り立ちます．\cite[`Farmer08`];
  論理結合子${\top}，${\land}，${\to}，${\forall}を以下のように定義します．

  \align[
    ${| \top |\coloneq \paren{\lambda p^\omicron.p} \doteq \paren{\lambda p^\omicron.p} |};
    ${| \phi_1 \land \phi_2 |\coloneq \paren{\lambda f^{\omicron \to \omicron \to \omicron}. \mathop{f} \top \top} \doteq \paren{\lambda f^{\omicron \to \omicron \to \omicron}. \mathop{f} \phi_1 \phi_2} |};
    ${| \phi_1 \to \phi_2 |\coloneq \paren{\phi_1 \land \phi_2} \doteq \phi_1 |};
    ${| \forall x^\tau.\phi |\coloneq \paren{\lambda x^\tau.\phi} \doteq \paren{\lambda x^\tau.\top} |};
  ];

  すると，以下の補題が成り立ちます．
}
+lemma{
  任意の構造${\M}と付値${\theta}について
  \listing{
    * ${\M,\theta \vDash \top}
    * ${\M,\theta \vDash \phi_1 \land \phi_2}であるとき，かつそのときに限り，${\M,\theta \vDash \phi_1}かつ${\M,\theta \vDash \phi_2}
    * ${\M,\theta \vDash \phi_1 \to \phi_2}であるとき，かつそのときに限り，${\M,\theta \vDash \phi_1}ならば${\M,\theta \vDash \phi_2}
    * ${\M,\theta \vDash \forall x^\tau.\phi}であるとき，かつそのときに限り，任意の元${a \in D_\tau}について${\M,\subst{a}{x} \theta \vDash \phi}
  }
  が成り立つ．
}
+p{
  以上の論理結合子を用いることで，他の様々な論理結合子も定義することができます．

  \align[
    ${| \bot |\coloneq \forall p^\omicron.p |};
    ${| \lnot \phi |\coloneq \phi \to \bot |};
    ${| \phi_1 \leftrightarrow \phi_2 |\coloneq \paren{\phi_1 \to \phi_2} \land \paren{\phi_2 \to \phi_1} |};
    ${| \phi_1 \lor \phi_2 |\coloneq \forall p^\omicron. \paren{\paren{\phi_1 \to p} \land \paren{\phi_2 \to p}} \to p |};
    ${| \exists x^\tau.\phi |\coloneq \forall p^\omicron. \paren{\forall x^\tau. \phi \to p} \to p |};
    ${| \uexists x^\tau.\phi |\coloneq \exists x^\tau.\phi \land \forall y^\tau. \subst{y}{x}\phi \to x \doteq y |};
  ];

  ここでの命題の上の量化${\forall p^\omicron.\phi}を用いましたが，このテクニックはGirardのSystem F(二階命題論理)で論理結合子を定義する際に使われるテクニックと同じものです．
  一連の議論により，高階論理が論理として十分強力な表現力を持つことがわかります．
  \footnote{個人的には，等号(${\doteq})で全ての論理結合子が表現できることは本質的ではなく，たまたまそうなっているだけな気がしています．
  等号だけあればよいという事実は技術的におもしろいですし実際今回の記事のように実装を目的としたケースでも役に立つのは間違いですが，私自身はこの事実に特に深遠な理由があるとは考えていません．}
}
+p{
  さて，最後に蛇足として，高階論理の他の形式化について述べておきます．
  今回の定義では組み込みの論理結合子は${\doteq}だけであり，他の論理結合子はすべて${\doteq}を用いて定義される派生物であるという立場をとりました．
  しかし，これが唯一のやり方というわけではありません．
  最も単純なやり方として，初めから全ての論理結合子とそれに関連する推論規則を組み込みとして定義するというのも考えることができます．
  その場合は組み込みの論理結合子とここまで見てきたような${\doteq}で定義した論理結合子が論理的に等価になるので，体系としては冗長性を含んでいるということになります．
  別のやり方として，${\doteq}を組み込みとして持たない高階論理の上で${\doteq}を派生物として定義することもできます．
  中でも，${\to}と${\forall}だけを組み込みとして持ち，他の論理結合子をそれらを用いて定義する方法がよく知られています．\cite[`Jacobs99`];
  すでに${\doteq}が単体でも十分な表現力を持っていることがわかっているので，${\to}と${\forall}を用いて${\doteq}を表現できれば全ての論理結合子が表現できることになります．
  具体的には以下のように${\doteq}を定義します．
  
  \eqn(${
    M_1 \doteq M_2 \coloneq \forall P^{\tau \to \omicron}. P M_1 \to P M_2
  });

  この${\doteq}は\dfn{Leibniz equality}と呼ばれる等号の定義です．
  ややびっくりするような定義ですが，これが実際に等号としての機能を果たすことはすぐにわかります．
}
+lemma{
  上で定義した${\doteq}について，${\den{M_1 \doteq M_2} = 0}であるとき，かつそのときに限り，${\den{M_1} = \den{M_2}}．
}
+proof{
  ${\den{M_1 \doteq M_2} = 0}ならば${\den{M_1} = \den{M_2}}を示す．(逆は明らか．)
  定義より${\den{\forall P^{\tau \to \omicron}. P M_1 \to P M_2} = 0}なので，任意の関数${P : D_\tau \to \Omega}について${\app{P}{\den{M_1}} = 0}ならば${\app{P}{\den{M_2}} = 0}である．
  ここで，${P}として，
  \eqn(${
    \app{P}{x} = \cases![
      (${0}, {${x = \den{M_1}}のとき});
      (${1}, {そうでないとき})
    ]
  });%
  をとると，${\app{P}{\den{M_1}} = 0}なので，${\app{P}{\den{M_2}} = 0}である．
  ${\app{P}{x}}が${0}を値にとるのは${x = \den{M_1}}のときだけなので，${\den{M_1} = \den{M_2}}である．
}
+p{
  このように${\doteq}を基本とせずとも等価な表現能力を持つ高階論理を定義することができます．
  \footnote{ただし，高階論理の演繹体系を考える場合，${\beta\eta}同値性の扱いなどについて${\doteq}を基本とする形式のほうが(この記事の範囲では)都合がよいです．}
}
>

+subsection?:(`hol-nd`){高階論理の演繹体系}<
+p{
  本節では高階論理の証明体系を与えます．
  証明体系の与え方には様々な流儀がありますが，この記事では(私の個人的な好みによって)自然演繹を採用します．
}
+p{
  本題に移る前に，ひとつ注意を述べます．
  前節\ref-subsection(`hol`);で導入した高階論理は\dfn{古典高階論理 (Classical HOL)}と呼ばれる種類の高階論理です．
  一方で，本節\ref-subsection(`hol-nd`);で定義する高階論理の証明体系は\dfn{直観主義高階論理 (Intuitionistic HOL)}に対応する証明体系です．
  古典公開論理と直観主義高階論理はアイデアはほぼ同じですが直観主義高階論理の方が意味論の定義が大変なので先に古典論理を説明しました．
  証明論的には両者の違いはそこまでややこしいものではなく，古典高階論理の演繹体系は直観主義高階論理の演繹体系を通常のやり方で古典にする(例えば，排中律を仮定する)だけで得られます．\cite[`BenzmullerM14`];
  本節で導入する演繹体系は\emph{HOL Light}\cite[`hol-light`];のコア言語から多相型を除いたもの，あるいは\emph{初等トポスの内部言語}\cite[`LambekS86`];を冪対象でなく指数対象で形式化したものと考えても良いです．
}
+p{
  それでは，高階論理の自然演繹を導入します．
  高階論理の自然演繹の判断は${\Phi \vdash_\Gamma \phi}という形です．
  ただしこのとき，${\Gamma}は型環境，${\phi}は論理式，${\Phi = \set{\phi_1,\cdots,\phi_n}}は論理式の有限集合で，各論理式について以下の型判断が成り立つとします．

  \math-list(${
  | \Gamma \vdash \phi : \omicron
  | \Gamma \vdash \phi_1 : \omicron
  | \cdots
  | \Gamma \vdash \phi_n : \omicron
  |});

  高階論理の導出は以下の三つの規則図式を基に定義されます．

  \math-list(${
  | \derive?:{\ \phi \in \Phi}{| |}{ \Phi \vdash_\Gamma \phi }
  | \derive?:{\ M =_{\beta\eta} N}{| |}{ \Phi \vdash_\Gamma M \doteq N }
  | \derive{| \Phi \vdash_\Gamma M_1 \doteq M_2 | \Phi \vdash_\Gamma \subst{M_1}{x} N |}{ \Phi \vdash_\Gamma \subst{M_2}{x} N }
  |});

  これらの図式に当てはまる規則を順に\dfn{仮定 (hypothesis)}，\dfn{${\doteq}導入 (${\doteq}-introduction)}，\dfn{${\doteq}除去 (${\doteq}-elimination)}と呼びます．
  通常，上記の三つの規則図式に加えて以下の二つの規則図式を加えます．

  \math-list(${
  | \derive{| \phi_1, \Phi \vdash_\Gamma \phi_2 | \phi_2, \Phi \vdash_\Gamma \phi_1 |}{ \Phi \vdash_\Gamma \phi_1 \doteq \phi_2 }
  | \derive?:{\ x \fresh \Phi}{| \Phi \vdash_{\set{x : \tau} \cup \Gamma} M \doteq N |}{ \Phi \vdash_\Gamma \paren{\lambda x^\tau.M} \doteq \paren{\lambda x^\tau.N}}
  |});

  これら二つの規則図式はそれぞれ\dfn{命題外延性 (propositional extensionality)}，\dfn{関数外延性 (functional extensionality)}と呼ばれます．
}
+p{
  この体系では，自然演繹に通常要請される性質が問題なく成立します．
  たとえば，証明の構造規則として弱化と置換の規則が許容可能になります．
}
+lemma{
  以下の規則は許容可能である．
  \math-list(${
  | \derive{| \Phi \vdash_\Gamma \phi |}{ \psi, \Phi \vdash_\Gamma \phi }
  | \derive{| \Phi \vdash_\Gamma \psi | \psi, \Phi \vdash_\Gamma \phi |}{ \Phi \vdash_\Gamma \phi }
  |});
}
+p{
  また，仮定についてのみならず型環境についても期待される性質が成り立ちます．
}
+lemma{
  以下の規則は許容可能である．
  \math-list(${
  | \derive{| \Phi \vdash_\Gamma \phi |}{ \Phi \vdash_{\set{x : \app{\A}{x}} \cup \Gamma} \phi }
  | \derive{| \Gamma \vdash M : \tau | \Phi \vdash_{\set{x : \tau} \cup \Gamma} \phi |}{ \subst{M}{x} \Phi \vdash_\Gamma \subst{M}{x} \phi }
  |});
}
+p{
  ${\IPC^\to}の場合と同様の理由で高階論理の判断の左辺は集合ではなく(有限の)リストとして定義しても証明可能性は変わりません．
  その場合，交換規則と縮約規則が許容可能になります．
  同様に，型環境をリストとして定義することも可能です．
}
+p{
  この演繹体系は集合論的意味論に対して(強い)健全性を持ちます．
}
+theorem{
  ${E \vdash_\Gamma \phi}のとき${E \vDash \phi}が成り立つ．
}
+p{
  一方でその逆，つまり集合論的意味論に対する完全性は成立しません．
  \footnote{一般に，高階論理の集合論的意味論に対して健全性・完全性・実効性(証明体系のある種の有限性)の全てを満たす演繹体系は存在しないことが知られています．
  今回の体系は健全性と実効性を持つので完全性を持ちません．
  一方で，トポス意味論に対しては今回の演繹体系は健全性・完全性・実効性の全てを満たします．}
  しかし，基本的な推論は行うことができます．
  例えば，\ref-subsection(`hol`);で導入した基本的な論理結合子について，その導入則と除去則が許容可能になります．

  \math-list(${
  | \derive{| |}{ \Phi \vdash_\Gamma \top }
  | \derive{| \Phi \vdash_\Gamma \phi_1 | \Phi \vdash_\Gamma \phi_2 |}{ \Phi \vdash_\Gamma \phi_1 \land \phi_2 }
  | \derive{| \Phi \vdash_\Gamma \phi_1 \land \phi_2 |}{ \Phi \vdash_\Gamma \phi_1 }
  | \derive{| \Phi \vdash_\Gamma \phi_1 \land \phi_2 |}{ \Phi \vdash_\Gamma \phi_2 }
  | \derive{| \phi_1, \Phi \vdash_\Gamma \phi_2 |}{ \Phi \vdash_\Gamma \phi_1 \to \phi_2 }
  | \derive{| \Phi \vdash_\Gamma \phi_1 \to \phi_2 | \Phi \vdash_\Gamma \phi_1 |}{ \Phi \vdash_\Gamma \phi_2 }
  | \derive?:{\ x \fresh \Phi}{| \Phi \vdash_{\set{x : \tau} \cup \Gamma} \phi |}{ \Phi \vdash_\Gamma \forall x^\tau. \phi }
  | \derive{| \Phi \vdash_\Gamma \forall x^\tau. \phi | \Gamma \vdash M : \tau |}{ \Phi \vdash_\Gamma \subst{M}{x} \phi }
  |});

  ただし${\land}，${\to}，${\forall}の導入則が許容可能であるためには命題外延性と関数外延性が必要です．
  \footnote{いずれも2，3行で証明できるので，興味がある方は証明してみてください．}
}
+p{
  さて，論理結合子を用いることで命題外延性と関数外延性の規則図式がなぜそう呼ばれるかがわかります．
  命題外延性の規則図式を追加することは以下の公理図式を仮定することと同値です．

  \eqn(${
    \paren{\phi_1 \leftrightarrow \phi_2} \leftrightarrow \paren{\phi_1 \doteq \phi_2}
  });

  これは「(解釈で)区別できないもの(命題)は同じである」というまさに(命題についての)外延性そのものです．
  同様に，関数外延性の規則図式を追加することは以下の公理図式を仮定することと同値です．

  \eqn(${
    \paren{\forall x^\tau. \mathop{f_1} x \doteq \mathop{f_2} x} \leftrightarrow \paren{f_1 \doteq f_2}
  });

  これもまさに「(適用によって)区別できないもの(関数)は同じである」という(関数についての)外延性に他なりません．
}
>

+subsection?:(`hol-impl`){高階論理の実装} <
+p{
  ついに高階論理を実装します．
  特に，対話的証明が行えることを確認します．
  高階論理の項は単純型付きラムダ計算に${\omicron}型と${\doteq}という項が増えただけです．
  \footnote{\ref-subsection(`hol`);と違い定数は考えませんが表現能力は変わりません．}
  実装は\ref-section(`stlc`);の各種の定義をほんの少し変更するだけで済みます．
  \footnote{実はこれはたまたまです．
  PHOASによるエンコーディングは実装が綺麗に行く場合とそうでない場合がかなりはっきり分かれているのですが，今回実装した範囲ではたまたまほんの少しの変更で済みました．}

  \d-code(`
  inductive type : Type
  | base : type
  | prop : type
  | arrow : type → type → type

  inductive term : type → Type
  | var : Π {t}, ν t → term t
  | lam : Π {t₁ t₂}, (ν t₁ → term t₂) → term (arrow t₁ t₂)
  | app : Π {t₁ t₂}, term (arrow t₁ t₂) → term t₁ → term t₂
  | eq : Π {t}, term t → term t → term prop
  `);
}
+p{
  \ref-subsection(`hol`);で定義したように様々な論理結合子を定義します．
  今回は論理結合子をメタレベルの関数ではなくオブジェクトレベルの関数として実装しました．
  \footnote{\code(`Forall`);と\code(`Exists`);は先頭を小文字にするとLeanの予約語と名前が衝突するため大文字から始めています．}

  \d-code(`
  def top : Term prop :=
  λ ν, eq (lam (λ x : ν prop, var x)) (lam (λ x, var x))

  def and : Term (arrow prop (arrow prop prop)) :=
  λ ν, lam (λ p₁, lam (λ p₂, eq (lam (λ f : ν (arrow _ (arrow _ prop)), app (app (var f) (top ν)) (top ν))) (lam (λ f, app (app (var f) (var p₁)) (var p₂)))))

  def Forall : Term (arrow (arrow t prop) prop) :=
  λ ν, lam (λ f, eq (var f) (lam (λ x, (top ν))))

  def bot : Term prop :=
  λ ν, app (Forall ν) (lam (λ p, var p))

  def implies : Term (arrow prop (arrow prop prop)) :=
  λ ν, lam (λ p₁, lam (λ p₂, eq (app (app (and ν) (var p₁)) (var p₂)) (var p₁)))

  def not : Term (arrow prop prop) :=
  λ ν, lam (λ p, app (app (implies ν) (var p)) (bot ν))

  def iff : Term (arrow prop (arrow prop prop)) :=
  λ ν, lam (λ p₁, lam (λ p₂, app (app (and ν) (app (app (implies ν) (var p₁)) (var p₂))) (app (app (implies ν) (var p₂)) (var p₁))))

  def or : Term (arrow prop (arrow prop prop)) :=
  λ ν, lam (λ p₁, lam (λ p₂, app (Forall ν) (lam (λ r, app (app (implies ν) (app (app (and ν) (app (app (implies ν) (var p₁)) (var r))) (app (app (implies ν) (var p₂)) (var r)))) (var r)))))

  def Exists : Term (arrow (arrow t prop) prop) :=
  λ ν, lam (λ f, app (Forall ν) (lam (λ r, app (app (implies ν) (app (Forall ν) (lam (λ x, app (app (implies ν) (app (var f) (var x))) (var r))))) (var r))))
  `);
}
+p{
  最後に高階論理の証明を定義して，全ての定義が終わりです．\footnote{\code(`theorem`);はLeanの予約語なので，代わりに\code(`Theorem`);と名付けます．}

  \d-code(`
  inductive Theorem : Π {Γ}, list (Judgment Γ prop) → Judgment Γ prop → Prop
  | hyp : Π {Γ Φ} {φ : Judgment Γ prop},
    φ ∈ Φ → Theorem Φ φ
  | refl : Π {Γ Φ t} {m₁ m₂ : Judgment Γ t},
    m₁ ≈ m₂ → Theorem Φ (eq m₁ m₂)
  | cong : Π {Γ Φ t} (m : Judgment (t :: Γ) prop) (m₂ m₁ : Judgment Γ t),
    Theorem Φ (eq m₁ m₂) → Theorem Φ (subst m m₁) → Theorem Φ (subst m m₂)
  | prop_ext : Π {Γ Φ} {φ₁ φ₂ : Judgment Γ prop},
    Theorem (φ₁ :: Φ) φ₂ → Theorem (φ₂ :: Φ) φ₁ → Theorem Φ (eq φ₁ φ₂)
  | fun_ext : Π {Γ Φ t₁ t₂} (m₁ m₂ : Judgment (t₁ :: Γ) t₂),
    Theorem (list.map weak Φ) (eq m₁ m₂) → Theorem Φ (eq (lam m₁) (lam m₂))
  `);

  これで定理証明支援系が完成しました．
  お疲れ様でした．
}
+p{
  と言ってもこれだけだとよくわからないので，実際に証明を書いてみます．
  たとえば，${p \vdash_\set{p : \omicron} \top \doteq p}を証明してみます．
  日本語にすると，「命題${p}が成り立っているとき，${p}は真である．」という意味です．
  これは当然証明できてほしいでしょう．
  答えを先に述べると，以下の証明木を構成し，Leanの型検査が通ればその証明が正しい証明であることがわかるという寸法です．

  \eqn(${
    \derive?:{\text!{\ 命題外延性}}{
    | \derive?:{\text!{\ 仮定}}{||}{\top, p \vdash_\set{p : \omicron} p}
    | \derive?:{\text!{\ ${\doteq}導入}}{| |}{p, p \vdash_\set{p : \omicron} \top}
    |}{ p \vdash_\set{p : \omicron} \top \doteq p }
  });

  判断${p \vdash_\set{p : \omicron} \top \doteq p}に対応するLeanの命題は\code(`@Theorem [prop] [var here] (eq (weak top) (var here))`);です．
  \code(`@Theorem`);は命題\code(`Theorem`);の暗黙の引数を明示的に与えるという構文です．
  この場合，\code(`@Theorem [prop] ...`);で判断の型環境${\Gamma}が${\omicron}型の一つの変数からなるという意味になります．
  よって，Leanの中で以下の\code(`...`);を埋めれば証明が完了します．

  \d-code(`
  def theorem1 : @Theorem [prop] [var here] (eq (weak top) (var here)) := ...
  `);

  ここで，普通にプログラミングしてLeanの項を作るのではなく，Leanのタクティック言語を用います．

  \d-code(`
  def theorem1 : @Theorem [prop] [var here] (eq (weak top) (var here)) :=
  begin
    -- ここを埋める
  end
  `);

  すると，Leanは以下のようなメッセージを出力して証明を埋めるように指示してきます．

  \console(`
  Tactic State:
  ⊢ Theorem [var here] (eq (weak top) (var here))
  `);

  出来上がるべき証明木は根が命題外延性なので\code(`prop_ext`);を用います．
  もし普通にLeanの証明を書くのであればここで単に\code(`prop_ext`);と書くのですが，今回はLeanの上で実装された演繹体系の証明を書いているので\code(`apply Theorem.prop_ext`);と書くのが正解です．

  \d-code(`
  def theorem1 : @Theorem [prop] [var here] (eq (weak top) (var here)) :=
  begin
    apply Theorem.prop_ext,
    -- ここを埋める
  end
  `);

  すると，Leanは証明すべき命題があと二つ残っているという旨のメッセージを出力します．

  \console(`
  Tactic State:
  2 goals
  ⊢ Theorem [weak top, var here] (var here)

  ⊢ Theorem [var here, var here] (weak top)
  `);

  このように，Lean自体のタクティック言語を用いることで今回作成した論理の証明を対話的に記述することができます．
  この証明を最後まで書くと以下のようになります．

  \d-code(`
  def theorem1 : @Theorem [prop] [var here] (eq (weak top) (var here)) :=
  begin
    apply Theorem.prop_ext,
    { apply Theorem.hyp,
      simp },
    { apply Theorem.refl,
      canonicity }
  end
  `);

  Lean自体のタクティック\code(`simp`);と\code(`canonicity`);はそれぞれ条件${p \in \sqbracket{\top, p}}と${\paren{\lambda p^\omicron.p} =_{\beta\eta} \paren{\lambda p^\omicron.p}}を証明するために用いました．
}
+p{
  最後にもう少し実用的な例として，${\Phi \vdash_\emptyset \phi_1 \land \phi_2}ならば${\Phi \vdash_\emptyset \phi_1}を証明します．
  詳細は省きますが，この証明支援系での証明がどのような雰囲気かがわかると思います．

  \d-code(`
  def theorem2 {φ₁ φ₂} {Φ : list (Judgment [] prop)} : Theorem Φ (app (app and φ₁) φ₂) → Theorem Φ φ₁ :=
  begin
    intro p,
    apply Theorem.cong
      (var here)
      φ₁
      (λ ν, app (lam (λ f, app (app (var f) (φ₁ ν)) (φ₂ ν))) (lam (λ p₁, lam (λ p₂, var p₁)))),
    { apply Theorem.refl,
      canonicity, },
    { apply Theorem.cong
        (@id (Judgment [arrow _ prop] prop) $ λ ν f, app (var f) (lam (λ p₁, lam (λ p₂, var p₁))))
        (λ ν, lam (λ f, app (app (var f) (φ₁ ν)) (φ₂ ν)))
        (@id (Judgment [] (arrow _ prop)) $ λ ν, lam (λ f, app (app (var f) (top ν)) (top ν))),
      { apply Theorem.cong
          (var here)
          (eq
            (@id (Judgment [] (arrow _ prop)) $ λ ν, lam (λ f, app (app (var f) (top ν)) (top ν)))
            (λ ν, lam (λ f, app (app (var f) (φ₁ ν)) (φ₂ ν))))
          (λ ν, app (app (lam (λ p₁, lam (λ p₂, eq (lam (λ f : ν (arrow _ (arrow _ prop)), app (app (var f) (top ν)) (top ν))) (lam (λ f, app (app (var f) (var p₁)) (var p₂)))))) (φ₁ ν)) (φ₂ ν)),
        { apply Theorem.refl,
          canonicity },
        { from p } },
      { apply Theorem.cong
          (var here)
          (@id (Judgment [] _) $ λ ν, app (lam (λ f, app (app (var f) (top ν)) (top ν))) (lam (λ p₁, lam (λ p₂, var p₁))))
          top,
        { apply Theorem.refl,
          canonicity },
        { apply Theorem.refl,
          canonicity } } }
  end
  `);
}
>
>

+section?:(`conclusion`){まとめ}<
+p{
  いかがでしたか？
}
+p{
  この記事では定理証明支援系であるLeanの上で高階論理に基づく定理証明支援系を作成しました．
  最終的なソースコードはgithub上に公開してあります．\cite[`leanhol`];
  紙面上は説明のためにかなり多くのコードを書いていますが，実際に最後の証明の部分にたどり着くだけなら200行ちょっと程度のコードだけで十分です．
  この数字が\emph{極めて}小さいと言えるかどうかは微妙ですが，かなり小さくコンパクトに実装できていると思います．
  この記事の企画の類似物としてHOL Light\cite[`hol-light`];やHaskHOL\cite[`haskhol`];がありますが，HOL Lightではパーサーや型推論器などの機能を一切提供しないコア部分が670行あります．
  当然ですが，今回の企画とHOL Lightでは定理証明支援系を小さく実装するというアイデアが共通しているのみで，参考程度の値にしかなりませんが，概観はつかめるかと思います．
}
+p{
  ちなみに，今回は実装言語として定理証明支援系を選んだので作成した定理証明支援系自体を検証したいと思うわけですが，残念ながらそれはできません．
  理由は\ref-subsection(`judgment1`);で説明したのと同じで，今回は色々と省コードにするためにかなり飛び道具を使っており，Leanの中では証明できないLeanの性質を用いてオブジェクト言語の健全性を保証しているからです．
  結局，PHOASを使うのをやめて普通に頑張って実装したほうが後々の拡張のためには良いかもしれません．
}
+p{
  さて，完走した感想ですが，今回の企画の趣旨である「\emph{省エネ・省コード}で定理証明支援系を実装」というのは自分が楽して省エネで記事を完成させるという意味もありました．
  実際，Leanのコードを書き始めてから最後の節の最後の大きな証明を書くまでには1週間かかっていなかったはずです．
  しかし，記事を書くにあたって理論的背景を本気で書き始めてしまったことと，説明をわかりやすくしようと色々工夫するうちにコード量と執筆料が膨大になったことで，まったく省エネではありませんでした．
  また，この記事は\SATySFi;で書いているのですが，今回は初めてそれなりの量の文章を\SATySFi;で記述するとあって，その学習にもそれなりに時間が取られました．
  \SATySFi;は設計や意味論が美しく概ね不満はないのですが，ドキュメントが足りなかったり，処理系のバグにそれなりの頻度で遭遇するなど，まだまだハマった時の対処法が大変な印象でした．
  自分の場合は\SATySFi;の神であるところのgfn氏に直接質問をしたり相談ができる環境だったのでまだよかったですが，独学で本格的に\SATySFi;を使うにはまだもう少し苦労が必要なようです．
  とはいえ，組版の品質は\TeX;に匹敵しますし，基本的な機能に絞ればすでに実用にも耐えられると思うので，あとは時間の問題かと思います．
  今回の執筆は自分にとっても非常に勉強になるとてもよい機会でした．
  高階論理，ラムダ計算，Lean，その他諸々，これらを初めて知った人でもそうでない人でも，この記事の内容が少しでも心に残れば幸いです．
}
>
>
>

end
