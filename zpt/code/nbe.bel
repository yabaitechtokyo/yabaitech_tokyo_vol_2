LF tp : type =
| base : tp
| arr  : tp → tp → tp
;

--name tp A.
--name tp B.

LF term : tp → type =
| app : term (arr A B) → term A → term B
| lam : (term A → term B) → term (arr A B)
;

schema tctx = some [ t : tp ] block x : term t;

% we use old-style definition because
% we need both `neut` and `norm` at the same time
neut : tp → type.
norm : tp → type.
nlam : (neut a → norm b) → norm (arr a b).
rapp : neut (arr a b) → norm a → neut b.
embed : neut base → norm base.

schema ctx = some [a:tp] block x:neut a;

stratified Sem : {g : ctx} [ ⊢ tp] -> ctype =
    | Base : [g ⊢ norm base] → Sem [g] [ ⊢ base]
    | Arr : {g : ctx} { A : [ ⊢ tp ] } { B : [ |- tp ]}
            ({h : ctx} {#S: [h |- g]} Sem [h] [ ⊢ A ] → Sem [h] [ ⊢ B ]) → Sem [g] [ ⊢ arr A B ]
;

rec sem_wkn : {h : ctx} {g : ctx} {#S : [h ⊢ g]} Sem [g] [ ⊢ A] → Sem [h] [ ⊢ A]  =
mlam h ⇒ mlam g ⇒ mlam S ⇒ fn e ⇒ case e of 
    | Base [g ⊢ R] ⇒ Base [h ⊢ R[#S]]
    | Arr [g] [⊢ A] [⊢ B] f ⇒ Arr [h] [⊢ A] [⊢ B] (mlam h' ⇒ mlam S' ⇒ f [h'] [h' ⊢ #S[#S']])
;

typedef Env : {g : tctx} {h : ctx} ctype =
{T : [ ⊢ tp]} {#p : [g ⊢ term T[]]} Sem [h] [ ⊢ T]
;

rec env_ext : Env [g] [h] → Sem [h] [ ⊢ S] → Env [g, x : term S[]] [h]  =
fn s ⇒ let  s : Env [g] [h] = s
        in fn e ⇒ mlam T ⇒ mlam p ⇒ case [g, x : term _ ⊢ #p] of 
            | [ g, x : term S ⊢ x ] ⇒ e
            | [ g, x : term S ⊢ #q[..] ] ⇒ s [ ⊢ T ] [ g ⊢ #q ]
;

rec env_wkn : {h' : ctx} {h : ctx} {#W : [h' ⊢ h]} Env [g] [h] → Env [g] [h']  =
mlam h' ⇒ mlam h ⇒ mlam W ⇒ fn s ⇒ 
    let  s : Env [g] [h] = s
    in mlam T ⇒ mlam p ⇒ sem_wkn [h'] [h] [h' ⊢ #W] (s [ ⊢ T] [g ⊢ #p])
;

rec eval : [g ⊢ term S[]] → Env [g] [h] → Sem [h] [ ⊢ S]  =
fn t ⇒ fn s ⇒
    let  s : Env [g] [h] = s
    in case t of
        | [g ⊢ #p] ⇒ s [ ⊢ _] [g ⊢ #p]
        | [g ⊢ lam (\x. E)] : [g ⊢ term (arr A[] B[])]
          ⇒ Arr [h] [⊢ A] [⊢ B] (mlam h' ⇒ mlam W ⇒ fn e ⇒ eval [g, x : term A[] ⊢ E] (env_ext (env_wkn [h'] [h] [h' ⊢ #W] s) e))
        | [g ⊢ app E1 E2] ⇒ let Arr [h] [⊢ A] [⊢ B] f = eval [g ⊢ E1] s
                             in f [h] [h ⊢ ..] (eval [g ⊢ E2] s)
;
