@require: math
@import: bib
@import: moreproof
@import: ../main/book-class
@import: ../lib/code

module Zpt : sig
  val article : block-text
end = struct

let-math \base = ${\iota}
let-math \arr ant succ = ${#ant \rightarrow #succ}
let-math \var name = ${#name}
let-math \lam name typ body = ${\lambda #name^{#typ} . #body}
let-math \app fn arg = ${#fn #arg}
let-math \judgeStlc ctx term typ = ${#ctx \vdash #term : #typ}
let-math \br = ${\rightarrow_{\beta}}
let-math \brm = ${\rightarrow_{\beta}^{*}}
let-math \subst m x n = ${#m \sqbracket{#x \coloneq #n}}

let article = '<
  +chapter ?:(`zpt-article`) (|
    bibliography = zpt-bibliography;
    title = {Belugaによるメタプログラミング入門};
    author = {zeptometer};
    |) <
    +section {はじめに} <
    +p {Beluga\footnote{http://complogic.cs.mcgill.ca/beluga/}はMcGill大学のBrigitte Pientkaらによって開発されている定理証明支援系というか関数型プログラミング言語というか、なんかそんなかんじのものです\footnote{Curry-Howard同型が理論的背景にあるから境目が曖昧になるんですわ、しゃーない}。公式サイトによる紹介は以下の通りです。}
    +p {\> Beluga is a functional programming language designed for reasoning about formal systems. It features direct support for object-level binding constructs using higher order abstract syntax and treats contexts as first class objects.}
    +p {なんかわかるようなわからないようなことが書いてありますね。これの意味するところがわかるところまで持っていくのがこの記事の目標となっております。がんばるぞー。記事の流れは以下のようになっております:
    \listing{
    * Normalization by Evaluationというテクニックについて解説をしながらReasonで実装し\footnote{Reasonを選んだのはなんとなく触ってみたかったからです!}、その実装の問題点について考える
    * Belugaの言語機能について解説しつつNormalization by Evaluationを再実装し、先の問題点が解消されていることを確認する
    }
    }
    >
    +section {インストール} <
    +p{GithubのREADMEを読め。}
    >
    +section {Normalization by Evaluationことはじめ} <
    +p{\dfn{Normalization by Evaluation}とは、λ計算やその亜種の項が与えられた時にその表示的意味論(あるいはeval関数)を経由して正規形を得るテクニックです。今回は対象として単純型付きλ計算(Simply Typed Lambda Calculus, STLC)を扱います\footnote{厳密にはChurch-styleです}。STLCの型は\dfn{基底型}${\base}と\dfn{関数型}${\arr{A}{B}}からなります。
    \math-list(${| A, B \coloncoloneq \base \mid \arr{A}{B} |});

    STLCの項は\dfn{変数}${\var{x}}、\dfn{関数}${\lam{x}{A}{M}}、\dfn{関数適用}${\app{M}{N}}からなります。
    \math-list(${| M, N \coloncoloneq \var{x} \mid \lam{x}{A}{M} \mid \app{M}{N} |});

    \dfn{環境}${\Gamma}を変数と型のペアの集合とするときに、\dfn{型判断}${\judgeStlc{\Gamma}{M}{A}}は「環境${\Gamma}の下で項${M}が型${A}を持つ」ことを表します。型判断は以下の規則に従って導出されます。

    \math-list (${
    | \bderive?:!{Var}
              { \judgeStlc{\Gamma}{\var{x}}{A} }
              {| x \colon A \in \Gamma |}
    | \bderive?:!{Abs}
              { \judgeStlc{\Gamma}{\lam{x}{A}{M}}{\arr{A}{B}} }
              {| \judgeStlc{\Gamma, x:A}{M}{B} |}
    | \bderive?:!{App}
              { \judgeStlc{\Gamma}{\app{M}{N}}{B} }
              {| \judgeStlc{\Gamma}{M}{\arr{A}{B}}
               | \judgeStlc{\Gamma}{N}{A}
               |}
    |});
    
    さて、これをReasonのコードで表してみましょう。STLCの型と項は以下のような代数的データ構造として定義可能です。
    }
    +Code.code(`
type typ =
  | Base
  | Arr(typ, typ);

type term =
  | Var(string)
  | Abs(string, typ, term)
  | App(term, term);
    `);
    +p{変数名はstringで表すことにしています。termは型判断とは独立して定義されているので導出できない項も表現できてしまいますが、今のところは妥当な型判断を伴う項だけを考えることにしましょう。}
    +p{さて、λ計算で重要な概念としてβ簡約があります。項の集合を${Term}をするとき、${\br}は${Term}上の二項関係で以下のような性質を満たすものと定義します。
    \align [
    ${| \app{\paren{\lam{x}{A}{M}}}{N} | \br \subst{M}{x}{N} | |};
    ${| \lam{x}{A}{M} | \br \lam{x}{A}{N} | \text!{if\ } M \br N |};
    ${| \app{M}{L} | \br \app{N}{L} | \text!{if\ } M \br N |};
    ${| \app{L}{M} | \br \app{L}{N} | \text!{if\ } M \br N |};
    ];
    ここで${\subst{M}{x}{N}}は「項M中における変数xの使用を項Nに置き換えて得られる項」を表しています。厳密な定義は実は結構面倒くさいのでここでは省略します。}
    +p{さて、STLCに関する重要な性質として今しがた定義したβ簡約の合流性と強正規化性があります。以降において二項関係${\brm}は${\br}の反射推移閉包とします。}
    +definition{項${M}が正規形である ${\Leftrightarrow} ${M \br N}を満たす項${N}が存在しない}
    +definition{
    ${\br}が\dfn{合流性}を満たす ${\Leftrightarrow} ${M \brm N_1}かつ${M \brm N_2}ならば${N_1 \brm L}かつ${N_2 \brm L}であるようなLが存在する
    }
    +definition{
    ${\br}が\dfn{強正規化性}を満たす ${\Leftrightarrow} 無限簡約列 ${M_1 \br M_2 \br \ldots}が存在しない
    }
    +p{合流性と強正規化性の帰結として、「STLC上で導出可能な項\footnote{厳密には「STLCの導出規則によって導出された型判断を伴う項」ですかね}は対応する正規形をただ一つもつ」ということが言えます。そうであればある項の正規形を得るプログラムを書きたいというのはごく自然な考えですね。
    \listing {
    * プログラム
    ** 入力: STLCの項
    ** 出力: 入力の項に対応する正規形
    ** 実装: ??
    }}
    +p{定義に対応する素朴な実装方針として「正規形を得るまで項にβ簡約を繰り返し適用する」というものが考えられます。でも実はこれが結構面倒くさいんです。
    面倒くささの一つは変数束縛の管理です。例えば以下のような型判断を考えてみましょう。
    \math-list(${| \judgeStlc{y \colon \arr{A}{B}}{\app{\paren{\lam{x}{\arr{A}{B}}{\lam{y}{A}{\app{\var{x}}{\var{y}}}}}}{y}}{\arr{A}{B}} |});
    定義によるとこの項は以下のようにβ簡約できます。
    \math-list(${| \app{\paren{\lam{x}{\arr{A}{B}}{\lam{y}{A}{\app{\var{x}}{\var{y}}}}}}{y} \br \subst{\paren{\lam{y}{A}{\app{\var{x}}{\var{y}}}}}{x}{y} |});
    ここで${\subst{M}{x}{N}}は\math(${});${M}中の${x}を${N}に置き換えた項だったわけですが、${\subst{\paren{\lam{y}{A}{\app{\var{x}}{\var{y}}}}}{x}{y}}の場合、λ抽象によって導入された${y}と${x}を置き換えた後に入る${y}で変数名が衝突してしまいます。
    \align[${| \subst{\paren{\lam{y}{A}{\app{\var{x}}{\var{y}}}}}{x}{y} | \neq \lam{y}{A}{\app{\var{y}}{\var{y}}}| \text!{// ダメ!}|}];
    こういった事態は\dfn{意図しない変数補足}と呼ばれたりします。こういった事態を避けるために、変数名の衝突が起きる場合にはλ抽象の束縛変数を衝突しないものに置き換える必要がでてきます。
    \align[
    ${| \subst{\paren{\lam{y}{A}{\app{\var{x}}{\var{y}}}}}{x}{y} | = \subst{\paren{\lam{z}{A}{\app{\var{x}}{\var{z}}}}}{x}{y} || \text!{// 束縛変数のyをzに置き換えると} |};
    ${| | = \lam{z}{A}{\app{\var{y}}{\var{z}}} || \text!{// オーケー} |}
    ];
    このようにちゃんとした置換を実装するためには意図しない変数補足が起きないように確認しつつ必要であれば束縛変数の名前を書き換えていく必要があるわけです\footnote{この束縛変数の名前の書き換えのことを\dfn{α変換}と呼びますが詳細は割愛します}。これをきちんと実装するのが一つ目の面倒くさいポイントです。β簡約に関してあまり本質的でない部分に実装を割かないといけないのがよろしくないですね。
    }
    +p{もう一つの面倒くさいポイントは「そもそもβ簡約を定義通りに実装するのがあまり直観的ではない」という点です\footnote{ほんまかこれ}。}
    +p{それに比べるとλ項が与えられた時にそれを評価する関数(いわゆるeval関数)を書くのは(少なくとも一部の人にとっては)かなり直観的で実装も楽に思われます。実際に書いてみましょう。最初に\code(`semantics`);という型を定義します。これはeval関数で評価することで得られる値を表します。今回は基底型に対応する値として\code(`MNat`);と関数型に対応する値として\code(`MAbs`);を用意します\footnote{今回は便宜上基底型をintとして扱っていますが特にintである必要はないです}。}
    +Code.code(`
type semantics =
  | MNat(int)
  | MAbs(semantics => semantics);
    `);
    +p{STLCの項を評価するためには評価される項の他に自由変数に対応する値を持つ環境が必要です。これを\code(`env`);という型として定義しましょう。これは変数名を与えた時に対応する\code(`semantics`);を返す関数として実装できます。空の環境\code(`envEmpty`);は必ず\code(`Undefined_variable`);を例外として投げます。また\code(`envExt`);は変数名と\code(`semantics`);のペアを受け取って既存の環境を拡張します。}
    +Code.code(`
type env = string => semantics;

type exn +=
  | Undefined_variable;

let envEmpty: env = _ => raise(Undefined_variable);

let envExt: (string, semantics, env) => env =
  (name, sem, env, name2) =>
    if (name === name2) {
      sem;
    } else {
      env(name2);
    };
    `);
    +p{然る後に\code(`eval`);の本体を書くことができます。項の構造に関する再帰を用いて素直に実装できます。}
    +Code.code(`
type exn +=
  | Wrong_application;

let rec evaluate: (term, env) => semantics =
  (m, e) => {
    switch (m) {
    | Var(name) => e(name)
    | Abs(name, _, n) =>
      MAbs(sem => evaluate(n, envExt(name, sem, e)))
    | App(n1, n2) =>
      let sem1 = evaluate(n1, e);
      let sem2 = evaluate(n2, e);

      switch (sem1) {
      | MAbs(f) => f(sem2)
      | MNat(_) => raise(Wrong_application)
      };
    };
  };
    `);
    +p{というわけですんなりと\code(`eval`);を実装することができました。いいですね。人生もこうすんなりといってほしいものです。\code(`eval`);の実装がβ簡約より楽と言われてもそもそもやってることが違うから関係ないじゃないか、と思われるかもしれません。ところがどっこい、この\code(`eval`);を使うことで実はSTLCの項の正規形を得ることができてしまうのです。それが今から紹介するNomalization by Evaluationなのです。}
    +p{Normalization by Evaluationはその名前の通り、eval関数(数学的に言えば表示的意味論)を用いてλ項の正規化を行うテクニックのことです。}
    >
    +section {BelugaでNbEを書く} <
      +math (${});

      +Code.code(`
LF tp : type =
| base : tp
| arr  : tp → tp → tp
;
  `);
      +Code.code(`
LF term : tp → type =
| app : term (arr a b) → term a → term b
| lam : (term a → term b) → term (arr a b)
;
      `);

      +Code.code(`
schema tctx = some [t : tp] block x : term t;

% we use old-style definition because
% we need both neut and norm at the same time
neut : tp → type.
norm : tp → type.
nlam : (neut a → norm b) → norm (arr a b).
rapp : neut (arr a b) → norm a → neut b.
embed : neut base → norm base.
      `);
    +Code.code(`
schema ctx = some [a:tp] block x:neut a;

stratified Sem : {g : ctx} [ ⊢ tp] -> ctype =
    | Base : [g ⊢ norm base] → Sem [g] [ ⊢ base]
    | Arr : {g : ctx} ({ h : ctx } {#S: [h ⊢ g]} Sem [h] [ ⊢ A] → Sem [h] [ ⊢ B]) → Sem [g] [ ⊢ arr A B]
;

rec sem_wkn : {h : ctx} {g : ctx} {#S : [h ⊢ g]} Sem [g] [ ⊢ A] → Sem [h] [ ⊢ A]  =
mlam h ⇒ mlam g ⇒ mlam S ⇒ fn e ⇒ case e of 
    | Base [g ⊢ R] ⇒ Base [h ⊢ R[#S]]
    | Arr [g] f ⇒ Arr [h] (mlam h' ⇒ mlam S' ⇒ f [h'] [h' ⊢ #S[#S']])
;

typedef Env : {g : tctx} {h : ctx} ctype =
{T : [ ⊢ tp]} {#p : [g ⊢ term T[]]} Sem [h] [ ⊢ T]
;

rec env_ext : Env [g] [h] → Sem [h] [ ⊢ S] → Env [g, x : term S[]] [h]  =
fn env ⇒ let  env : Env [g] [h] = env
          in fn sem ⇒ mlam T ⇒ mlam p ⇒ case [g, x : term _ ⊢ #p] of 
              | [ g, x : term S ⊢ x ] ⇒ sem
              | [ g, x : term S ⊢ #q[..] ] ⇒ env [ ⊢ T ] [ g ⊢ #q ]
;

rec env_wkn : {h' : ctx} {h : ctx} {#W : [h' ⊢ h]} Env [g] [h] → Env [g] [h']  =
mlam h' ⇒ mlam h ⇒ mlam W ⇒ fn env ⇒ 
    let env : Env [g] [h] = env
    in mlam T ⇒ mlam p ⇒ sem_wkn [h'] [h] [h' ⊢ #W] (env [ ⊢ T] [g ⊢ #p])
;

rec eval : [g ⊢ term S[]] → Env [g] [h] → Sem [h] [ ⊢ S]  =
fn tm ⇒ fn env ⇒
    let env : Env [g] [h] = env
    in case tm of
        | [g ⊢ #p] ⇒ env [ ⊢ _] [g ⊢ #p]
        | [g ⊢ lam (\x. E)] ⇒
              Arr [h] (mlam h' ⇒ mlam W ⇒ fn sem ⇒
                          eval [g, x : term _ ⊢ E] (env_ext (env_wkn [h'] [h] [h' ⊢ #W] env) sem))
        | [g ⊢ app E1 E2] ⇒ let Arr [h] f = eval [g ⊢ E1] env
                             in f [h] [h ⊢ ..] (eval [g ⊢ E2] env)
;
    `);
    +Code.code(`
mlam R ⇒ fn n ⇒ let [g ⊢ N] = n in [g ⊢ rapp R N];

rec reify : Sem [h] [ ⊢ A] → [h ⊢ norm A[]] =
fn sem ⇒ case sem of
    | Base [h ⊢ R] ⇒ [h ⊢ R]
    | Arr [g] f ⇒ let  [g, x : neut _ ⊢ N] =
                   reify (f [g, x : neut _] [g, x ⊢ ..] (reflect [g, x : neut _ ⊢ x]))
                   in [g ⊢ nlam (\x. N)]
and reflect : [h ⊢ neut A[]] → Sem [h] [ ⊢ A] =
fn n ⇒ let [h ⊢ R] : [h ⊢ neut A[]] = n
        in case [ ⊢ A] of
            | [ ⊢ base ] ⇒ Base [h ⊢ embed R]
            | [ ⊢ arr B C ] ⇒ Arr [h] (mlam h' ⇒ mlam W ⇒ fn tm ⇒
                                           reflect (app' [h' ⊢ R[#W]] (reify tm)))
;

rec nbe : Env [g] [h] → [g ⊢ term A[]] → [h ⊢ norm A[]] =
fn env ⇒ fn tm ⇒ reify (eval tm env)
;
    `);
    >
    +section {理論的背景について} <
    >
  >
>
end
