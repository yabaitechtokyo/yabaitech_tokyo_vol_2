@import: bib
@import: ../main/book-class

let pohe-article = '<
  +chapter ?:(`pohe-article`) (|
    bibliography = pohe-bibliography;
    title = {Writing a (micro)kernel in Rust in 12 days};
    author = {pohe};
    |) <

    +section{1st day} <

      +subsection{Introduction} <
        +p {
          ハロー！私の認識が正しければ、あなたにはこのページの上部にでかでかと書いてある記事のタイトルが見えているはずだ。
          ということは、この記事が一体何をするものなのかはわかっているね？
          そう、ずばり、今から12日間でRustでマイクロカーネルを書き上げるのだ！
          カーネルは、オペレーティングシステムの中核コンポーネントだ。
          CPUのもっとも権限の高い空間で動作し、コンピュータのすべてを支配しなければならない。
          それを0から自分で書くというのはとてもエキサイティングな体験だ。
          プログラマーの3大作ってみたいもの、コンパイラ・CPU・オペレーティングシステムのまさに3つ目にあたるからね。
          そして今回書いていくカーネルはただのカーネルではなくマイクロカーネルだ。
          マイクロカーネルとは何か、という詳しい話はあとに回すとして、今回マイクロカーネルを選んだ大きな理由は二つある。
          一つは、マイクロカーネルはサイズがとても小さいということだ。
          実用レベルのOSであるRedoxでも、マイクロカーネル部分のコードは1万行未満だ。
          Linuxカーネルのような巨大なモノリシックカーネルを自作してみようというのは途方もない話だが、
          マイクロカーネルならば短い期間でゼロからでも完成させることができるはずだ。
          そして、もう片方の理由は、L4マイクロカーネルファミリーという有名なマイクロカーネルの仕様が存在することだ。
          実装するべき完成図がはっきりしているから学びながら開発していくのに都合がいいし、しかも無事仕様をみたせたときには自作したカーネルのうえで、
          既存のユーザーランドアプリケーションが動作することになる。
          OSを自作するとき、こんなに嬉しいことはないだろう！
          小さな労力でこれを達成したら、あとはサーバーなどの自分のユーザーランドをインクリメンタルに開発してゆくことも可能だ。

          長々と説明したけれど、つまりはマイクロカーネルは自作をするにはピッタリだってこと！
          また、今回はカーネルを書くプログラミング言語として、Rustを使うことにする。
          Rust言語は、2019年の今最も注目されているプログラミング言語の一つだ。
          特に低レイヤーの分野においては、モダンな言語機能を一通りそろっていることによる快適性と、
          所有権という新しい概念によるGC不要なメモリ安全性から注目されている。
          (C言語を思い出せ！) コミュニティ全体で、システムレイヤ―での応用を考慮しながら開発が進められているのも魅力的なポイントだ。
          2019年にOSを書く際にRustで始めてみようと思うのは奇妙なことでは全くないだろう。
          そんなわけで、私は今からRustでマイクロカーネルを書き始める、というわけだ。
        }

        +p {
          さて、この記事を読むにあたって前提とする知識は三つだけ。
          一つめ。
           それなりのプログラミング経験。
          単にこれから「変数とは何か？」とか、「ライブラリ」は何か、それに「42とはいったい何のマジックナンバーなのか？」とか言ったことを
          いちいち説明していかないというだけだ。
          Webプログラマーだから低レイヤには自信がない？大変結構！実際の開発経験があるということは前提条件として十分すぎるほどだ。

          二つめ。
          オペレーティングシステムに関するベーシックな理解。
          オペレーティングシステムの基本的な概念 -例えばプロセスとかデバイスドライバとかいったもの- 
          について、詳しくはなくていいからだいたいの知識は前提としたい。
          ご存知の通り、これらの概念をゼロからわかりやすく説明しようとすれば、大学の講義で出会ったような分厚い教科書が必要だからね。
          ただし詳細な説明こそはしないが、Wikipediaの一段落目に出てきそうな説明文くらいは書く元気はあるから、
          大学時代の記憶が怪しいひとや大学時代の記憶がまだない人も安心してほしい。
          それに、仮想メモリといったたとえ職業プログラマでも普段低レイヤ領域になじみがなければきちんと理解していないような概念は、
          CPUでの仕様を含めて詳しく説明するだろう。

          最後に三つめ。
          さらに、Rust言語のチュートリアル程度の知識。
          残念ながら、この記事ではRust言語の文法や所有権など基本的な概念の入門まではカバーしない予定だ。
          でもチュートリアルをやったことがあるというだけで十分。
          なぜかって？私がそうだから！私のRust経験はまだチュートリアルを終わらせたことと簡単な2つのプログラムを書いたことしかない。
          この記事では、必要になる知識をあらかじめ系統的に章立てして、天下り的に読者の皆さまに説明していくことは_しない_。
          そうではなくて、12日間という期間でマイクロカーネルを実際に私がstep by stepで実装し、その過程を綴っていく。
          そして、開発に必要になることや私が経験したトラブルを読者の皆さんと共有する。
          だから、低レイヤ開発で必要になるRustの知識、それに単にRust初心者がぶつかるよくある問題なんかもカバーしていけるだろう。
          (私が体を張ることによってね。
          )基本的には、この記事はマイクロカーネルを作るための体系だった教科書であるよりかは、私のマイクロカーネル開発の日記により近いものとなる予定だ。
          私が実際に開発した際に（若干）読者の皆様を意識しながらそのログを残し、それにたいして抜け落ちている説明を後から書き加える形にする（予定）。
          だからきっと、このシリーズは読者の皆様が実際にRustでマイクロカーネルを作り上げてみるのにはピッタリなものとなるに違いない。
          ぜひ読者の皆様も、私の12日間を文章で追体験するだけでなく、1日ずつコードを書いていき、
          マイクロカーネルをゼロから作り上げるエキサイティングな12日間を実際に過ごしてほしい。
          それでは、早速(私達の)開発1日目を始めよう。
        }
      >

      +subsection{What is microkernel? What is L4?} <
      >

      +subsection{Let's boot L4 Pistachio in Qemu} <
        +listing{
          *  Write that I assume we're in a Linux environment. Especially, that I'm in WSL environment.
        }
      >

      +subsection{The specification: 12 APIs of L4 microkernel} <
      >
    >

    +section{2nd Day: Writing a Minimal Kernel in Rust} <
      +p {
        昨日の挑戦1日目では、マイクロカーネルの概念とL4マイクロカーネルの仕様を学び、実際にPistachioカーネルをQemu上で動作させてみた。
        今日からは、ありもののカーネルを動かすのではなく、自分の手でL4マイクロカーネルの実装を始めることにする。
        その第一歩として今日は、Rustでベアメタルプログラミングに挑戦し、自作の最小のカーネルをQemu上で動かしてみよう。
        今日の目的は、一旦マイクロカーネルのことは忘れ、Rustでのベアメタル開発の世界に飛び込んでみることだ。
        以降の章で、今日作るカーネルをもとにして少しずつマイクロカーネルを作りあげていくことになる。
        さて、ふだんはWebプログラムなどの開発を行っていて、低レイヤでのプログラミングにはなじみがないという方はどのくらいいるだろうか。
        そのような方はぜひ一手順一手順実際に手を動かしてみて、低レイヤプログラミングの楽しさを知ってほしい。
        この章では基本的な低レイヤプログラミングの基礎知識も1ステップずつ網羅していくので、通常のプログラミングに関する前提知識があれば十分だ。

        一方、この手のプログラミングはもう慣れっこだという読者の方もいるだろう。
        私自身も、ベアメタルのプログラムを書くことはそれほど珍しいことではない。
        Xv6という小さなUNIXライクなオペレーティングシステムをMIPSアーキテクチャに移植したことがあるし、
        それを自分たちで設計・FPGA上に実装したオリジナルCPUに移植したこともある。
        また、CPUの仮想化支援機構を利用して既存のオペレーティングシステムにLinuxパーソナリティを実現するNoahというソフトウェアを作った際も、
        かなりの時間を仮想環境内のベアメタルプログラミングに費やした。
        だけどこのような低レイヤプログラミングに慣れっこだというのは、あくまで「C言語を使う限りにおいては」だ。
        だから、Rustでカーネルを書くと何が楽になり、何が独特の難しいポイントか、GNU Binutilsなどとの連携はどのような形になるのかといった点に興味が津々である。
        私と同じようにC言語でならこの手のプログラミングに慣れているという方も、
        いつもの慣れた手順がRustの世界ではどのように様変わりするのかということを楽しんでもらえると嬉しい。

      }

      +p {
        -----------------------
      }

      +subsection{Bare Metal Programming} <
        +p {
          さて、いよいよRustでのベアメタルプログラミングの世界に飛び込んでみる時がきた。
          実はRustの世界ではすでに、["Writing an OS in Rust"][https://os.phil-opp.com/]という素晴らしいWebシリーズが存在する。
          このシリーズは、Rustでベアメタルプログラミングをするための準備から、x86アーキテクチャの基礎知識までカバーしているシリーズだ。
          Rustでオペレーティングシステムを書くなら、これをチェックしない手はない。
          私も今日Rustで小さなカーネルを書いてみるにあたって、このシリーズのお世話になることにした。
          実のところ、私がこの記事を、教科書のようなスタイルではなく私の個人的なカーネル開発のログを時系列で綴っていくスタイルにしようと思ったのも
          このシリーズの存在が理由だ。
          すでに素晴らしい教科書が存在するというのに、そこに不完全なものを新たに一つ加えたところで何になるだろう！
          (ただし"Writing an OS in Rust"は2019年1月時点ではまだ未完結で、ページングに関する解説が執筆されているところであることには注意してほしい。
          だが、活発に執筆が続けられているので、すぐに完結することだろう。
          )さて、早速"Writing an OS in Rust"の第1章、"A Freestanding Rust Binary"に従って、Rustでのベアメタルプログラミングに入門してみることにしよう。
          "Writing an OS in Rust"は主にPhilipp Oppermann氏によって執筆されている。
          これから毎度毎度"Writing an OS in Rust"とフルタイトルと呼ぶのは、書くのも読むのも大変だから、"Phipp's"と呼んでいくことにしよう。

        }

        +p {
          まずは、Rustのツールチェインの準備からだ。
          Philipp'sで説明されているところによると、Rustでオペレーティングシステムを作るにあたっては、nightlyコンパイラがまだ必要らしい。
          私はRustに触れたのが比較的最近なので、RustツールチェインのインストールにはRustupツールを使っている。
          その場合は下記のコマンドでnightlyコンパイラを簡単にインストールすることができる。
          もし、Rustに触れてみたのがかなり昔で、RustツールチェインのインストールにRustupを使わなかったという読者の方は、
          Rustupを使ってツールチェインをインストールしなおすのがいいだろう。
        }

        +code(`$ rustup install nightly`);

        +p {
          これでRustツールチェインの準備は完了だ。シンプル！
          さて、ここでこれから自分がカーネルを書いていくことになるRustプロジェクトを初期化しておく。
          これはこのプロジェクトに名前を付けるということでもある。
          これから作っていくカーネルは最終的にはL4マイクロカーネルファミリーのマイクロカーネルになる。
          Rust製のL4カーネル実装はたぶん私のものが初めてになるだろうから、それにふさわしい名前として、
          私は自分のカーネルを\code(`Rusty L4`);と呼ぶことにした。
          だからここで私が走らせたコマンドはこうだ。
        }

        +code(`$ cd ~/Dropbox/develop/rust
               $ cargo new rusty_l4 --bin --edition 2018`);
        +p {
          cargoコマンドの使い方は覚えているだろうか？念のためおさらいしておくとcargoコマンドはRust標準のビルドツールだ。
          Rustのプロジェクトは基本的にcargoコマンドを使って管理していく。
          \code(`--edition 2018`);は見慣れないオプションだ。
          これは2018年ギリギリにリリースされたばかりのRust 2018の機能を有効にするためのオプションである。
          Rust 2018は多くの便利な新機能が導入されたエキサイティングなバージョンだ。
          特にこだわりがなければこれを使わない手はない。
          \code(`async`); / \code(`await`); 構文が2018に間に合わなかったのは残念だけどね。
        }

        +p {
          さらに、Philipp'sにしたがって、Rust L4のプロジェクトではnightlyコンパイラをデフォルトで使用するように設定する。
        }

        +code(`$ rustup override add nightly`);

        +p {
          // TODO: About Freestanding binary
        }

      >

      +subsection{Write a Bare Metal Program in Rust} <
        +listing{
          *  Write a target file for Rust
          *  Sooo rich crates
          *  Neeed to be extended to Multiboot
        }
      >

      +subsection{Booting: How a Kernel Boots} <
      >

      +subsection{Boot it!} <
      >

      +subsection{VGA Text Mode} <
        +p {
          動いたね。

        }
      >

      +subsection{Multiboot Header by Myself} <
        +p {
          さて、先ほどまではPhilipp'sの2nd editionに基づいてRustでカーネルを書いてきた。
          Philipp氏が用意してきたCrateの手軽さもあいまって、
          あまりベアメタルプログラミングらしいことをせずともあれよあれよという間にHello, World!が無事画面に躍り出ることになった。

        }

        +listing{
          * 正直に言おう。ちょっとこれじゃ高級すぎてよくわからない！
          * また、マイクロカーネル方式と相性が悪いという現実的な問題もある。

          * 古き良きMultiboot Headerをスクラッチから書いていこう。
          * まず、startup.Sを書いて、Qemuのシリアル機能を使って無事'A'という文字を出力！無事ブートできたみたいだ。

          * ロングモードまで入ってさっさとRustの世界に帰ることにしよう。

          * 個人的にはこの部分を書くのがいつも一番面倒だ！1GBページとGDTをさっさと用意してしまおう
           
          * WSL上だと（というかおそらく実際にgrubで起動していない環境だと）grub-mkrescueでうまくブートデバイスが作れない。
            \code(`grub-pc-bin`);をインストールするとうまくブータブルISOが作られるようになる。
             See https://github.com/Microsoft/WSL/issues/807
          * Rustとは関係ない、Multibootの部分で随分と苦労したが、Philippの高級なcrateを使ってブートした時と同じHello, Worldを無事表示できた。
            これでRusty L4の最小カーネルは完成だ！
        }
      >
    >


    +section{3rd Day: Write a Microkernel Server for L4 Pistachio} <
      +p {
        さて、この挑戦も今日も3日目だ。
        もっとも、開発をし終わったあとにこの文章を編集して、こまぎれの記録を一つにまとめて皆さんにはお見せしているから、
        私としては実際にはだいぶ日数が経っているのだけど。
        ともあれ、昨日で私は、Rustでのベアメタルプログラミングの世界を体験してきた。
        最終的には、Qemuの画面上に、無事に"Hello, World!"を表示できたわけだ。
        何度も目にするものではあるが、自分で表示させる機会は意外とそう多くはない例の文字列だね。
        ベアメタルプログラミングをしているにもかかわらず、Cでの開発のときと違い、crateを使って簡単にブートができてしまったことや、
        \code(`println!`);マクロが使えるまでの道のりの簡単さは本当に驚異的だった。
        ベアメタルプログラミングをやっているにもかかわらず、Traitなんていう普段Web開発をしているときに使うような高級な概念を普通に使える感覚も新鮮だ。
        Rustはベアメタルプログラミングをもっと簡単に、そして楽しくしてくれそうだというのは間違いないね。
      }
      +p {
        おっと！Rustに関する話に少し脱線してしまったようだ。
        そろそろ今日、3日目にやることについて話そうじゃないか。
        今日は一旦フルスクラッチのベアメタルプログラミングの世界から離れて、L4マイクロカーネル上での世界に戻ってみる。
      }
      +listing{
        * L4マイクロカーネル用の簡単なサーバーを書いてみる
        * 明日以降、これを自分で書いたカーネルの上で走らせることを目標とするためだ。
        * 今回書こうとしているサーバーは、1番目に起動することを想定する特殊なサーバーであることには留意してほしい。
          多分普通にサーバーを書く分にはもっと苦労しないはずだ。

        * とはいえ、今だいぶ苦労しているところだ。
          L4マイクロカーネルは、大学の講義での詳細な技術情報や1アプリケーションが必要とするユーザーランドのAPIのドキュメントは
          たくさん見つかるかと思いきや、今まさに私が必要としている、
          「最初に起動するサーバーは、どうやってカーネルと通信するのか？」
          「最初に起動するサーバーは何をすることが期待されているのか？」というユーザーランドをゼロから書くための情報がなかなか見つからない

        * 今回のこの作業を通して、一般にCPU上でOSのカーネルがメモリ空間をどう管理するかについても触れるかもしれない。
      }
    >

    +subsection{Yet Memos for Draft...} <
      +subsection{Sigma0} <
        +listing{
          * Nontheless, I have to understand how sigma0 interacts with kernel.
            I wanna know how kernel boots sigma0, and what is the duty of sigma0.
            Basically, all what I want to do in the pseudo Sigma0 I'm writing now is just printing "Hello, World!", as I did in the 2nd day.
            So, I want to do some cheating for the simplicty if possible.
            I do only the least duty expected by the kernel in Sigma0, and after it,
            printing the glorious greeting by writing constants to the specific memory addresses.
            That's all!
          * To understand the duty, and of course how I can communicate with the kernel by IPC, I started reading the source code of Sigma0 of Pistachio.
        }
      >
    >


  >
>
