@import: bib
@import: ../main/book-class
@import: ../lib/code

let-block ctx +line-break it =
  line-break true true ctx (read-inline ctx it)

let pohe-article = '<
  +chapter ?:(`pohe-article`) (|
    bibliography = pohe-bibliography;
    title = {Writing a (micro)kernel in Rust in 12 days};
    author = {pohe};
    |) <

  +section{Introduction} <
    +p {
      ハロー！私の認識が正しければ、あなたにはこのページの上部にでかでかと書いてある記事のタイトルが見えているはずだ。
      見えるかい？ "Writing a (micro)kernel in Rust in 12 days"だ。
      見えたならきっと、この記事が一体何をする記事なのかはわかっているね？
      そう、ずばり、12日間でRustでマイクロカーネルを書き上げるのだ！
    }
    +p {
      この記事は、私がRustでカーネルを書いてみたいと思ったことから始まった開発ログだ。
      Rust言語は、2019年の今最も注目されているプログラミング言語の一つで、
      低レイヤーの分野においては、特にモダンな言語機能を一通りそろっていることによる快適性と、
      所有権という新しい概念によるGCに頼らないメモリ安全性から注目されている。(C言語でのメモリ関連のデバッグの苦労を思い出せ！)
      コミュニティ全体で、システムレイヤ―での応用を考慮しながら開発が進められているのも魅力的なポイントだ。
      だから、2019年にカーネルを書く際にRustでやってみようと思うのは全く奇妙なことではないだろう。
    }
    +p {
      一方カーネルは、ご存知オペレーティングシステムの中核コンポーネントだ。
      CPUのもっとも権限の高い空間で動作し、コンピュータのすべてを支配しなければならない。
      それを0から自分で書くというのはとてもエキサイティングな体験だ。
      プログラマーの3大作ってみたいもの、コンパイラ・CPU・オペレーティングシステムのまさに3つ目にあたるからね。
      そして今回書いていくカーネルはただのカーネルではなくマイクロカーネルだ。
    }
    +p {
      マイクロカーネルとは何か、という詳しい話はあとに回すとして、今回マイクロカーネルを選んだ大きな理由は二つある。
      一つは、マイクロカーネルはサイズがとても小さいということ。
      実用レベルのOSであるRedoxでも、マイクロカーネル部分のコードは1万行未満だ。
      Linuxカーネルのような巨大なモノリシックカーネルを自作してみようというのは途方もない話だが、
      マイクロカーネルならば短い期間でゼロからでも完成させることができるはずだ。
      実は私は去年ついに大学院を卒業して会社員になり、（あるいはなってしまい、）無事自由時間が今までの7分の2に減ってしまった！
      だから短い期間で完成させたいというのは実に切実な願いで、そのために作るカーネルとしてマイクロカーネルを選んだのは自然なことだったわけだ。
    }
    +p {
      そして、もう一つの理由は、L4マイクロカーネルファミリーという有名なマイクロカーネルの仕様が存在すること。
      実装するべき完成図がはっきりしているから学びながら開発していくのに都合がいいし、しかも無事仕様をみたせたときには自作したカーネルのうえで、
      既存のユーザーランドアプリケーションが動作することになる。
      OSを自作するとき、こんなに嬉しいことはないだろう！
      小さな労力でこれを達成したら、あとはサーバーなどの自分のユーザーランドをインクリメンタルに開発してゆくことも可能だ。
      L4マイクロカーネルは実世界で使われた実績もあってまだ活発に開発・研究がされている。そして今回扱うL4 X.2 APIのいいところは、
      何と言ったってシステムコールが12個しかないことだ！そう聞いたらなおさら短期間で作れそうな気がしてこないかい？
      仕様があるってことに加えて、しかもその仕様が小さいわけだ。これは一つ目の理由をさらに強いものにしてくれるね。
    }
    +p {
      色々と説明したけれど、つまりはマイクロカーネルは自作をするにはピッタリだってこと！
      そんなわけで、私は今からRustでマイクロカーネルを書き始める、というわけだ。
    }

    +subsubsection{前提知識} <
      +p {
        さて、この記事を読むにあたって前提とする知識が二つある。
        一つめ。
        オペレーティングシステムの仕組みに関するベーシックな理解。
        オペレーティングシステムの基本的な概念 -例えばカーネルとかデバイスドライバ、プロセスとかいったものの仕組み- 
        について、実際に自分で書いて見たことはなくていいから、だいたいの知識は前提としたい。つまりは学部の講義レベルの知識だ。
        ご存知の通り、これらの概念をゼロからわかりやすく説明しようとすれば、大学の講義で出会ったような分厚い教科書が必要だからね。
        本当は普通のWebプログラミング経験があれば十分、ということにしたかったんだけれど、残念ながら私の原稿の速度と締め切りがそれを許さなかった！
        
        ただし詳細な説明こそはしないが、Wikipediaの一段落目に出てきそうな説明文くらいは書く元気はあるから、
        大学時代の記憶が怪しい人や大学時代の記憶がたまたままだない人もある程度安心してほしい。
      }
      +p {
        そして二つめ。
        さらに、Rust言語のチュートリアル程度の知識。
        残念ながら、この記事ではRust言語の文法や所有権など基本的な概念の入門まではカバーしない予定だ。
        でもチュートリアルをやったことがあるというだけで十分。
        なぜかって？私がそうだから！私のRust経験はまだチュートリアルを終わらせたことと簡単な2つのプログラムを書いたことしかない。
        ただしこの記事では、必要になる知識をあらかじめ系統的に章立てして、天下り的に読者の皆さまに説明していくことは\emph{しない}。
        そうではなくて、12日間という期間でマイクロカーネルを実際に私がstep by stepで実装し、その過程を綴っていく。
        そして、開発に必要になることや私が経験したトラブルを読者の皆さんと共有する。
        だから、低レイヤ開発で必要になるRustの知識、それに単にRust初心者がぶつかるよくある問題なんかもカバーしていけるだろう。
        (私が体を張ることによってね。)
      }
      +p {
        基本的には、この記事はマイクロカーネルを作るための体系だった教科書であるよりかは、私のマイクロカーネル開発の日記により近いものとなる予定だ。
        私が実際に開発した際に（若干）読者の皆様を意識しながらそのログを残し、それにたいして抜け落ちている説明を後から書き加える形にする（予定）。
        だからきっと、このシリーズは読者の皆様が実際にRustでマイクロカーネルを作り上げてみるのにはピッタリなものとなるに違いない。
        ぜひ読者の皆様も、私の12日間を文章で追体験するだけでなく、1日ずつコードを書いていき、
        マイクロカーネルをゼロから作り上げるエキサイティングな12日間を実際に過ごしてほしい。
        それでは、早速私(達の)開発1日目を始めよう。
      }
    >
  >

  +section{1st day: L4 Microkernel} <
    +p {
      記念すべき第1日は、L4マイクロカーネルに関する概念の整理だ。
      普通のカーネルと違って、マイクロカーネルは普段LinuxやmacOSで開発を行っていては、あまりなじみがなくても仕方がない。
      \footnote{
        Windowsに触れると話はややこしくなる。
        Windowsはマイクロカーネルの要素が色濃く残っているのだ。だから少なくともしばらくはWindowsの話はしない。
      }
      そこで1日目では、具体的な目標であるL4の仕様についての話を始める前に、マイクロカーネルの概念についても整理しようと思う。
      そして最後に、実際にL4 X.2の実装であるPistachioカーネルをビルドして、Qemu上で動かしてみる。
      そうすれば、明日以降私達が何を作ればいいのかがはっきりするだろう。
    }

    +subsection{What is Microkernel?} <
      +p {
        早速だが、マイクロカーネルとは何だろう？ひと段落で言えばだいたい次のようになる。
      }
      +code(`
        マイクロカーネル（英: microkernel）とはオペレーティングシステムの設計思想、及びそのようなOSのカーネル部の名称である。
        OSが担う各種機能のうち、必要最小限のみをカーネル空間に残し、残りをユーザーレベルに移すことで全体の設計が簡素化でき、結果的にカスタマイズ性が向上し、性能も向上できるというOSの設計手法のことである。
        カーネル本体が小規模な機能に限定されるので「マイクロカーネル」と呼ばれるが、必ずしも小さなOSを構成するとは限らない。 
      `);
      +p {
        以上、Wikipedia日本語版\cite[`microkernel_wikipedia`];からの引用だ。
        Wikipediaの一段落目に出てきそうな説明文くらいは書くといったが、その約束を早速果たしてしまった。
        ちなみに、マイクロカーネルの対義語にあたる、普通のカーネルの呼び名はモノリシックカーネルという。
        Linuxカーネルはこのモノリシックカーネルの典型的な例だ。
        とはいっても、これだけじゃ何が何だかという感じだろうし、重要な特徴をかいつまんで説明していこう。
      }

      +subsubsection{極小性} <

        +p {
          まず、重要なことは、さっきの引用で説明されているように、カーネルには必要最小限の機能のみがあるということだ。
          カーネル空間では、CPUの特権命令を発行する必要があるような、本当にプリミティブな機能だけが動く。
          そして、それ以上の機能は、ユーザー空間で動くプロセスが、そのプリミティブな機能をシステムコールとして使うことで実現していく。
          これらのユーザー空間のプロセスはマイクロカーネルの世界では、「サーバー」と呼ばれる。
          L4カーネルを例にとれば、カーネル空間で動く機能はおおまかに次の5つだけとなる。
        }
        +enumerate {
          * スレッドプリミティブ
          * スケジューリング
          * メモリ空間の制御
          * IPC
          * 割り込み制御
        }
        +p {
          もしかしたら、一見カーネル空間が担う機能としては普通のリストに見えるかもしれない。
          だから、普通のLinuxやmacOSのカーネル空間には存在しているけれど、このリストでは実は欠けているものをいくつか挙げてみよう。
          まず、真っ先に気づきやすいのはデバイスドライバがリストにないことだ。
          マイクロカーネルアーキテクチャでは、デバイスドライバはユーザー空間で実現される。
          最近のLinuxで提供されている、User space I/Oにあたるものがマイクロカーネルからデバイスドライバに提供され、
          デバイスドライバはユーザー空間にいながら特定の許可されたメモリ空間やIOポートをたたくことでデバイス管理を実現する。
          これにより、マイクロカーネルではデバイスドライバがクラッシュしたとして、ほかのユーザー空間プロセスに影響を与えることはないわけだ。
          ファイルシステムもデバイスドライバと似たような方法でユーザー空間に移されている。
        }
        +p {
          欠けているものその2として挙げたいのは、プロセス管理機構。
          一見すると、あれ、それは(1)で実現されているんじゃ？と思うかもね。でも実はそういうわけじゃない。
          L4でいうスレッドとは、レジスタの値とメモリ空間の組を保存したもの、くらいの意味合いしかない。
          これもそれだけ聞くと普通そんなものなんじゃ？と思ってしまうだろうから、モノリシックカーネルではプロセス管理のためにもっとどんな機能があるか思い出そう。
        }
        +p {
          分かりやすいのはプロセスの起動だろう。
          \code(`execve`);システムコールは、POSIX OSでプロセスを起動するためのシステムコールだとざっくり言ってしまってもいいと思うが、
          （おっと、あなたが顔をしかめるのが目に浮かぶようだ！でもforkやexecの話は今は本質じゃないから先にすすませてくれ。）
          このシステムコールの第一引数は起動したい実行ファイルのパスだ。
          例えばmacOSでは、ここにMach-Oフォーマットのファイルへのパスが渡される。
          すると、カーネルは、あたらしいスレッドプリミティブを作成し、Mach-Oをパースしてそのスレッドのメモリ空間に展開してくれるわけだ。
          一方、L4のシステムコールではそこまでやってくれない。
          そもそもファイルシステムはカーネルにないし、ファイルシステムを用意してあげたとして、Mach-Oをパースするのはユーザー空間の役割だ。
          L4のカーネルがやってくれるのは、単に空のメモリ空間と空のレジスタを持ったスケジュール可能なスレッドプリミティブを作ることだけ。
          それ以外のすべてはユーザー空間に実装されたサーバーの役割だ。
          例えばプロセスが開いているファイルハンドルの管理、プロセスの実行ユーザーや実行グループの管理といった機能もすべて同様にL4カーネルには欠けている。
          L4のスレッドプリミティブを呼ぶだけでは、いわゆるプロセスらしいことは何も実現できないってことだ。
        }
        +p {
          このように色々な機能がユーザー空間のサーバーの役割とされて、カーネルは最小の機能だけを実現することになっているのが、「マイクロカーネル」と呼ばれる理由だろう。
          これにより、カーネルのサイズはとても小さいものになる。
          それに、それぞれのサーバーはメモリ空間が分離されているから、デバイスドライバについての説明で話したように、一つ一つがクラッシュしても、
          その影響を最小限に抑えることができ、堅牢性も向上する。
        }
      >

      +subsubsection{OSパーソナリティ} <

        +p {
          じゃあ、そんな最小限なカーネルを使ってしまったら、いったいどうやって全体としてLinuxみたいなオペレーティングシステムを実現するのかって？
          一言でいえば、そういうマイクロカーネルに足りない部分を管理するサーバーを一つ作る、というのが答えだ。
          普通のカーネルに必要なもろもろの機能を実現するこのサーバーは、OSパーソナリティやペルソナと呼ばれる。
          OSパーソナリティサーバーが、ファイルシステムやデバイスドライバをIPCを通じて制御し、それをもとにPOSIXのforkやread, writeのようなユーザーアプリケーションから
          見えるシステムコールを実装して一つのオペレーティングシステムを実現する、というのがマイクロカーネルベースのオペレーティングシステムの一つの形だ。
        }
        +p {
          マイクロカーネルの面白いところは、このパーソナリティサーバーを取り換えることで同じマイクロカーネルでも違うオペレーティングシステムを実現できることだ。
          L4の上でLinuxパーソナリティを走らせれば、Linuxのアプリケーションが動くし、
          (仮にあるとすればだが)macOSパーソナリティを走らせればmacOSのアプリケーションが動く。
          おまけにパーソナリティはユーザー空間のサーバーだから、同時にいくつも並行して走らせることができる。
          \footnote{まるでハイパーバイザみたいな話だが、実際マイクロカーネルは現代の仮想化機構と共通点が多い。}
          マイクロカーネルとパーソナリティの試みは、面白い具体例が色々ある。
          Fiasco.OC L4カーネル上でLinuxが動くL4 Linux\cite[`l4linux`];。
          これは今も開発が活発に続いている。何しろFiasco.OCは商用L4マイクロカーネルだ。
          過去の例でいえば、MinixがL4Ka上で動くMinix/L4\cite[`l4minix`];、Machカーネル上でLinuxが動くMkLinux\cite[`mklinux`];、それに同じくMach上で動くOSであるGNU Hurd\cite[`hurd`];.
          他にも色々あるから、探してみるのもいいんじゃないだろうか。
        }
        +p {
          この面白い特徴から、一度あるマイクロカーネルの互換カーネルを作ってしまえば、
          その上でそのマイクロカーネル用のOSパーソナリティやサーバー群が動くことになる！
          これがIntroductionで説明した自作カーネルを既存のマイクロカーネルの仕様に準拠させるモチベーションの一つだ。
        }

      >
    >

    +subsection{L4 Microkernel} <
      +p {
        さて、これでマイクロカーネルの一般的な概念の紹介はおしまいだ。
        まぁ覚えていてほしいことは、マイクロカーネルは小さな機能だけで構成されていること。
        それに、通常のオペレーティングシステムとしての機能は、マイクロカーネルの上で動くOSパーソナリティで実現されることだ。
        この節からは、L4マイクロカーネルについての話を始めよう。
      }
      +p {
        L4は、先ほど説明したマイクロカーネルアーキテクチャに基づくマイクロカーネルの一つだ。
        L4と呼ばれるマイクロカーネル実装は複数あるから、きちんと呼ぶなら「L4マイクロカーネルファミリー」になる。
        このファミリーというのは、だいたい「Windowsファミリー」と同じくらいの感覚だ。
        Windowsには95系とNT系があるわけだけど、どちらもWindowsカーネルと呼ばれるし、それぞれでもバージョン毎にだいぶ違いがある。
        つまり、ファミリーとは一つの実装を指しているわけではなく、共通の系譜を継いだお仲間たちだというわけだね。
        そして、L4マイクロカーネルファミリーの系譜の起源は、Jochen Liedtke先生による1993年の、ずばり「L4」だ。\cite[`l4`];
        \footnote{L3というL4の前身のカーネルもある。そして正確にはそちらが起源なのだが、説明を簡単にするためL4から始めたい。}
        L4を起源とするL4ファミリーの系譜の図をWikipediaから\ref-figure(`fig:l4family`);に引用した。
        論文 "From L3 to seL4 - What Have We Learnt in 20 Years of L4 Microkernels?"\cite[`l4_lessons`];は、
        L4の重要な概念がよくまとまっているうえに、この系譜図上のL4からseL4にいたるまでにL4ファミリーが解決してきた問題や、
        設計の変遷をまとめたとても良い読み物だ。
        L4についてより詳しい資料を読みたくなったらまずはこれを参照してほしい。(http://sigops.org/s/conferences/sosp/2013/papers/p133-elphinstone.pdf)


        \figure ?:(`fig:l4family`)
          {Family tree of the L4 microkernel with time line(\cite[`l4_wikipedia`];より引用)}
          <+image-frame{\insert-image(14cm)(`../pohe/figure/L4_family_tree.jpg`);}>
      }
      +subsubsection{マイクロカーネルとパフォーマンス - L4の革命} <
        +p {
          L4の開発がはじめられたモチベーションは、マイクロカーネルが抱えていた大きな問題の解決にあった。
          その問題とは、パフォーマンスの悪さだ。
          マイクロカーネルは、その設計上IPCがボトルネックになりやすいということがよく議論にあがる。\cite[`l4_lessons`];
          マイクロカーネルでは、システムコールがサーバー間の複数のIPCで実装され、そしてIPCはコンテキストスイッチを伴う。
          一方、モノリシックカーネルのシステムコールは通常1回のコンテキストスイッチで済むから、
          比較するとマイクロカーネルではシステムコールのコストが割高になってしまう。
        }
        +p {
          L4は、Liedtkeがこの問題を解決するために開発した、画期的なマイクロカーネルだった。
          先ほど名前だけ少し出た、Mach\cite[`mach_wikipedia`];というマイクロカーネルでは、IPCのコストが顕著だった。
          \footnote{MachはMinixと並んでもっとも著名なマイクロカーネルの一つだろう。現在のmacOSのXNUカーネルの源流でもある。
          著名であるにもかかわらず、不名誉な文脈でしか触れられないことに不満を持つファンもいるだろうから、ここでその栄誉を称えておく！}
          このMachはL4の文脈では、「第1世代マイクロカーネル」として言及される。もちろん、L4が第2世代だという流れでだけどね\;)
          Liedtkeは、L4で極小性をキーコンセプトとしてマイクロカーネルをデザインしなおした。
          IPCの機構はMachに比べて極端に単純になり、メッセージサイズも小さくなりCPUのキャッシュになるべくすべてのメッセージが載るように設計した。
          スケジューリングなども単純化され、さらにはカーネルすべてをアセンブリで書いてしまうというものすごい執念でありうる極小のマイクロカーネルを完成させた。
          結果はどうなったと思う？なんとIPCはMachに比べて20倍も高速化したのだ！\cite[`l4_wikipedia`];
          ちなみに、のちにL4カーネルはCやC++で書き直されたが、パフォーマンスは悪化しなかったので安心してほしい。
          さらに後続の研究では、LinuxパーソナリティがL4上で実装され、本物のLinuxカーネルに比べても数パーセントのオーバーヘッドしか発生しないことが示された。\cite[`l4_lessons`];
          こうしてL4により、マイクロカーネルは実用的なオーバーヘッドで実現できるということが示されたのだ。
        }
      >
      +subsubsection{マイクロカーネルの逆襲} <
        +p {
          L4の登場以降、マイクロカーネルは様々な方向に発展している。
          MINIXのタネンバウム教授が2016年に"Lessons learned from 30 years of Minix"で述べているように、
          L4ベースのマイクロカーネルはほとんどあらゆるiPhoneのセキュリティチップで動いているし、QNXは色々な組み込み機器で実用化されている。
          こいういう機器では、少々の性能のオーバーヘッドよりも信頼性が重要だからだ。\cite[`minix_lessons`];
          そのタネンバウム先生のMINIX自身も、実は世界中のIntel x86 CPUで動いていたという事実が最近判明した。\cite[`intel_minix`];
        }
        +p {
          マイクロカーネルの発展は実用化方面だけではない。
          一番クールなプロダクトはやはりseL4だろう。\cite[`sel4_web`];
          seL4は、マイクロカーネルのコードサイズが小さいことを利用して、その正当性をIsabellaで証明したおそらく世界で唯一のカーネルだ。
          メモリ安全性といった一般的な性質や、ポートベースのポリシーシステムが決して違反されないことなどを数学的に証明している。
          しかもseL4はそのAPI設計自体もかなりシンプルで良い感じだ。
          実際、今回実装する仕様の対象としてseL4はかなり有力な候補だった。しかし、仕様の大きさの問題でこの記事ではseL4を選ばなかった。
          また、seL4のAPIのそれ以前のL4ファミリーの共通点はほとんどないことも注意事項かもしれない。思想上の家族、といったところなのかもね。
        }
        +p {
          普段Linuxの世界で生きていると、1992年、つまりL4発表の前年のリーナスとタネンバウム先生\cite[`linus_tan`];の論争から
          マイクロカーネルの時は止まっているかのように思えてしまうものだ。
          しかしL4以降、マイクロカーネルのパフォーマンスは大幅に改善した。
          実用化という面では、QNX, MINIX, L4の数を足してみれば、もしかすると実はLinuxよりも多くの数のマイクロカーネルが世界では動いている可能性すらある。
          証明済みカーネルというユニークな成果も、マイクロカーネルでなければ不可能だったものだ。
          あまり大きくは知られていないけれど、マイクロカーネルの世界はどんどん発展していて、いつの間にか「逆襲」を果たしていたというわけかもね。
        }
      >
    >

    +subsection{Let's boot L4 Pistachio in Qemu} <
      +p {
        少しおしゃべりが過ぎたようだ。
        そろそろ作業の方に入った方がいいだろうね！
      }
      +listing{
        *  Write that I assume we're in a Linux environment. Especially, that I'm in WSL environment.
      }
    >

    +subsection{The specification: 12 APIs of L4 microkernel} <
    >
  >

  +section{2nd Day: Writing a Minimal Kernel in Rust} <
    +p {
      昨日の挑戦1日目では、マイクロカーネルの概念とL4マイクロカーネルの仕様を学び、実際にPistachioカーネルをQemu上で動作させてみた。
      今日からは、ありもののカーネルを動かすのではなく、自分の手でL4マイクロカーネルの実装を始めることにする。
      その第一歩として今日は、Rustでベアメタルプログラミングに挑戦し、自作の最小のカーネルをQemu上で動かしてみよう。
      今日の目的は、一旦マイクロカーネルのことは忘れ、Rustでのベアメタル開発の世界に飛び込んでみることだ。
      以降の章で、今日作るカーネルをもとにして少しずつマイクロカーネルを作りあげていくことになる。
      さて、ふだんはWebプログラムなどの開発を行っていて、低レイヤでのプログラミングにはなじみがないという方はどのくらいいるだろうか。
      そのような方はぜひ一手順一手順実際に手を動かしてみて、低レイヤプログラミングの楽しさを知ってほしい。
      この章では基本的な低レイヤプログラミングの基礎知識も1ステップずつ網羅していくので、通常のプログラミングに関する前提知識があれば十分だ。

      一方、この手のプログラミングはもう慣れっこだという読者の方もいるだろう。
      私自身も、ベアメタルのプログラムを書くことはそれほど珍しいことではない。
      Xv6という小さなUNIXライクなオペレーティングシステムをMIPSアーキテクチャに移植したことがあるし、
      それを自分たちで設計・FPGA上に実装したオリジナルCPUに移植したこともある。
      また、CPUの仮想化支援機構を利用して既存のオペレーティングシステムにLinuxパーソナリティを実現するNoahというソフトウェアを作った際も、
      かなりの時間を仮想環境内のベアメタルプログラミングに費やした。
      だけどこのような低レイヤプログラミングに慣れっこだというのは、あくまで「C言語を使う限りにおいては」だ。
      だから、Rustでカーネルを書くと何が楽になり、何が独特の難しいポイントか、GNU Binutilsなどとの連携はどのような形になるのかといった点に興味が津々である。
      私と同じようにC言語でならこの手のプログラミングに慣れているという方も、
      いつもの慣れた手順がRustの世界ではどのように様変わりするのかということを楽しんでもらえると嬉しい。

    }

    +p {
      -----------------------
    }

    +subsection{Bare Metal Programming} <
      +p {
        さて、いよいよRustでのベアメタルプログラミングの世界に飛び込んでみる時がきた。
        実はRustの世界ではすでに、["Writing an OS in Rust"][https://os.phil-opp.com/]という素晴らしいWebシリーズが存在する。
        このシリーズは、Rustでベアメタルプログラミングをするための準備から、x86アーキテクチャの基礎知識までカバーしているシリーズだ。
        Rustでオペレーティングシステムを書くなら、これをチェックしない手はない。
        私も今日Rustで小さなカーネルを書いてみるにあたって、このシリーズのお世話になることにした。
        実のところ、私がこの記事を、教科書のようなスタイルではなく私の個人的なカーネル開発のログを時系列で綴っていくスタイルにしようと思ったのも
        このシリーズの存在が理由だ。
        すでに素晴らしい教科書が存在するというのに、そこに不完全なものを新たに一つ加えたところで何になるだろう！
        (ただし"Writing an OS in Rust"は2019年1月時点ではまだ未完結で、ページングに関する解説が執筆されているところであることには注意してほしい。
        だが、活発に執筆が続けられているので、すぐに完結することだろう。
        )さて、早速"Writing an OS in Rust"の第1章、"A Freestanding Rust Binary"に従って、Rustでのベアメタルプログラミングに入門してみることにしよう。
        "Writing an OS in Rust"は主にPhilipp Oppermann氏によって執筆されている。
        これから毎度毎度"Writing an OS in Rust"とフルタイトルと呼ぶのは、書くのも読むのも大変だから、"Phipp's"と呼んでいくことにしよう。

      }

      +p {
        まずは、Rustのツールチェインの準備からだ。
        Philipp'sで説明されているところによると、Rustでオペレーティングシステムを作るにあたっては、nightlyコンパイラがまだ必要らしい。
        私はRustに触れたのが比較的最近なので、RustツールチェインのインストールにはRustupツールを使っている。
        その場合は下記のコマンドでnightlyコンパイラを簡単にインストールすることができる。
        もし、Rustに触れてみたのがかなり昔で、RustツールチェインのインストールにRustupを使わなかったという読者の方は、
        Rustupを使ってツールチェインをインストールしなおすのがいいだろう。
      }

      +code(`$ rustup install nightly`);

      +p {
        これでRustツールチェインの準備は完了だ。シンプル！
        さて、ここでこれから自分がカーネルを書いていくことになるRustプロジェクトを初期化しておく。
        これはこのプロジェクトに名前を付けるということでもある。
        これから作っていくカーネルは最終的にはL4マイクロカーネルファミリーのマイクロカーネルになる。
        Rust製のL4カーネル実装はたぶん私のものが初めてになるだろうから、それにふさわしい名前として、
        私は自分のカーネルを\code(`Rusty L4`);と呼ぶことにした。
        だからここで私が走らせたコマンドはこうだ。
      }

      +code(`$ cd ~/Dropbox/develop/rust
             $ cargo new rusty_l4 --bin --edition 2018`);
      +p {
        cargoコマンドの使い方は覚えているだろうか？念のためおさらいしておくとcargoコマンドはRust標準のビルドツールだ。
        Rustのプロジェクトは基本的にcargoコマンドを使って管理していく。
        \code(`--edition 2018`);は見慣れないオプションだ。
        これは2018年ギリギリにリリースされたばかりのRust 2018の機能を有効にするためのオプションである。
        Rust 2018は多くの便利な新機能が導入されたエキサイティングなバージョンだ。
        特にこだわりがなければこれを使わない手はない。
        \code(`async`); / \code(`await`); 構文が2018に間に合わなかったのは残念だけどね。
      }

      +p {
        さらに、Philipp'sにしたがって、Rust L4のプロジェクトではnightlyコンパイラをデフォルトで使用するように設定する。
      }

      +code(`$ rustup override add nightly`);

      +p {
        // TODO: About Freestanding binary
      }

    >

    +subsection{Write a Bare Metal Program in Rust} <
      +listing{
        *  Write a target file for Rust
        *  Sooo rich crates
        *  Neeed to be extended to Multiboot
      }
    >

    +subsection{Booting: How a Kernel Boots} <
    >

    +subsection{Boot it!} <
    >

    +subsection{VGA Text Mode} <
      +p {
        動いたね。

      }
    >

    +subsection{Multiboot Header by Myself} <
      +p {
        さて、先ほどまではPhilipp'sの2nd editionに基づいてRustでカーネルを書いてきた。
        Philipp氏が用意してきたCrateの手軽さもあいまって、
        あまりベアメタルプログラミングらしいことをせずともあれよあれよという間にHello, World!が無事画面に躍り出ることになった。

      }

      +listing{
        * 正直に言おう。ちょっとこれじゃ高級すぎてよくわからない！
        * また、マイクロカーネル方式と相性が悪いという現実的な問題もある。

        * 古き良きMultiboot Headerをスクラッチから書いていこう。
        * まず、startup.Sを書いて、Qemuのシリアル機能を使って無事'A'という文字を出力！無事ブートできたみたいだ。

        * ロングモードまで入ってさっさとRustの世界に帰ることにしよう。

        * 個人的にはこの部分を書くのがいつも一番面倒だ！1GBページとGDTをさっさと用意してしまおう
         
        * WSL上だと（というかおそらく実際にgrubで起動していない環境だと）grub-mkrescueでうまくブートデバイスが作れない。
          \code(`grub-pc-bin`);をインストールするとうまくブータブルISOが作られるようになる。
           See https://github.com/Microsoft/WSL/issues/807
        * Rustとは関係ない、Multibootの部分で随分と苦労したが、Philippの高級なcrateを使ってブートした時と同じHello, Worldを無事表示できた。
          これでRusty L4の最小カーネルは完成だ！
      }
    >
  >


    +section{3rd Day: Write a Microkernel Server for L4 Pistachio} <
      +p {
        さて、この挑戦も今日も3日目だ。
        もっとも、開発をし終わったあとにこの文章を編集して、こまぎれの記録を一つにまとめて皆さんにはお見せしているから、
        私としては実際にはだいぶ日数が経っているのだけど。
        ともあれ、昨日で私は、Rustでのベアメタルプログラミングの世界を体験してきた。
        最終的には、Qemuの画面上に、無事に"Hello, World!"を表示できたわけだ。
        何度も目にするものではあるが、自分で表示させる機会は意外とそう多くはない例の文字列だね。
        ベアメタルプログラミングをしているにもかかわらず、Cでの開発のときと違い、crateを使って簡単にブートができてしまったことや、
        \code(`println!`);マクロが使えるまでの道のりの簡単さは本当に驚異的だった。
        ベアメタルプログラミングをやっているにもかかわらず、Traitなんていう普段Web開発をしているときに使うような高級な概念を普通に使える感覚も新鮮だ。
        Rustはベアメタルプログラミングをもっと簡単に、そして楽しくしてくれそうだというのは間違いないね。
      }
      +p {
        おっと！Rustに関する話に少し脱線してしまったようだ。
        そろそろ今日、3日目にやることについて話そうじゃないか。
        今日は一旦フルスクラッチのベアメタルプログラミングの世界から離れて、L4マイクロカーネル上での世界に戻ってみる。
      }
      +listing{
        * L4マイクロカーネル用の簡単なサーバーを書いてみる
        * 明日以降、これを自分で書いたカーネルの上で走らせることを目標とするためだ。
        * 今回書こうとしているサーバーは、1番目に起動することを想定する特殊なサーバーであることには留意してほしい。
          多分普通にサーバーを書く分にはもっと苦労しないはずだ。

        * とはいえ、今だいぶ苦労しているところだ。
          L4マイクロカーネルは、大学の講義での詳細な技術情報や1アプリケーションが必要とするユーザーランドのAPIのドキュメントは
          たくさん見つかるかと思いきや、今まさに私が必要としている、
          「最初に起動するサーバーは、どうやってカーネルと通信するのか？」
          「最初に起動するサーバーは何をすることが期待されているのか？」というユーザーランドをゼロから書くための情報がなかなか見つからない

        * 今回のこの作業を通して、一般にCPU上でOSのカーネルがメモリ空間をどう管理するかについても触れるかもしれない。
      }
    >

    +subsection{Yet Memos for Draft...} <
      +subsection{Sigma0} <
        +listing{
          * Nontheless, I have to understand how sigma0 interacts with kernel.
            I wanna know how kernel boots sigma0, and what is the duty of sigma0.
            Basically, all what I want to do in the pseudo Sigma0 I'm writing now is just printing "Hello, World!", as I did in the 2nd day.
            So, I want to do some cheating for the simplicty if possible.
            I do only the least duty expected by the kernel in Sigma0, and after it,
            printing the glorious greeting by writing constants to the specific memory addresses.
            That's all!
          * To understand the duty, and of course how I can communicate with the kernel by IPC, I started reading the source code of Sigma0 of Pistachio.
        }
      >
    >


  +section{Welcome} <
    +code(`
      　　　　∧＿∧　やあ
      　　　（´・ω・｀)　　　　　　/　　　　　　　ようこそ、バーボンハウスへ。 
      　　／∇y:::::::＼　　　[￣￣]　　　　　　このテキーラはサービスだから、まず飲んで落ち着いて欲しい。
      　　|:::⊃:|:::::|　　　|──|　　　　　　
      ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|　うん、「未完」なんだ。済まない。だいたい4分の1で尻切れトンボに
      ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|￣　なってる。仏の顔もって言うしね、謝って許してもらおうとも思ってない。
      ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|
      　　　　∇　∇　∇　∇　　　|　　　でも、この記事の目次を見たとき、君は、きっと言葉では
      　　　　┴　┴　┴　┴　　　|　　　言い表せない「ときめき」みたいなものを感じてくれたと思う。 
      ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|　　　殺伐とした世の中で、そういう気持ちを忘れないで欲しい 
      ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|　　　そう思って、この記事を書いたんだ。
      　　　　　　　　　　　　　　　|
      　　　　　　　　　　　　　　　|　　　じゃあ、注文を聞こうか。
    `);
  >

  >
>
