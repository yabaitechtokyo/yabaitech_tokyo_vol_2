@import: bib
@import: ../main/book-class
@import: ../lib/code

let-block ctx +line-break it =
  line-break true true ctx (read-inline ctx it)

let pohe-article = '<
  +chapter ?:(`pohe-article`) (|
    bibliography = pohe-bibliography;
    title = {Writing a (micro)kernel in Rust in 12 days};
    author = {nullpo_head};
    |) <

  +section{Introduction} <
    +p {
      ハロー！私の認識が正しければ、あなたにはこのページの上部にでかでかと書いてある記事のタイトルが見えているはずだ。
      見えるかい？ "Writing a (micro)kernel in Rust in 12 days"だ。
      見えたならきっと、この記事が一体何をする記事なのかはわかっているね？
      そう、ずばり、12日間でRustでマイクロカーネルを書き上げるのだ！
    }
    +p {
      この記事は、私がRustでカーネルを書いてみたいと思ったことから始まった開発ログだ。
      Rust言語は、2019年の今最も注目されているプログラミング言語の一つで、
      低レイヤーの分野においては、特にモダンな言語機能を一通りそろっていることによる快適性と、
      所有権という新しい概念によるGCに頼らないメモリ安全性から注目されている。(C言語でのメモリ関連のデバッグの苦労を思い出せ！)
      コミュニティ全体で、システムレイヤ―での応用を考慮しながら開発が進められているのも魅力的なポイントだ。
      だから、2019年にカーネルを書く際にRustでやってみようと思うのは全く奇妙なことではないだろう。
    }
    +p {
      一方カーネルは、ご存知オペレーティングシステムの中核コンポーネントだ。
      CPUのもっとも権限の高い空間で動作し、コンピュータのすべてを支配しなければならない。
      それを0から自分で書くというのはとてもエキサイティングな体験だと思う。
      プログラマーの「3大作ってみたいもの」によくあがる、コンパイラ・CPU・オペレーティングシステムのまさに3つ目にもあたるしね。
      そして今回書いていくカーネルはただのカーネルではなくマイクロカーネルだ。
    }
    +p {
      マイクロカーネルとは何か、という詳しい話はあとに回すとして、今回マイクロカーネルを選んだ大きな理由は二つある。
      一つは、マイクロカーネルはサイズがとても小さいということ。
      実用レベルのOSであるRedoxでも、マイクロカーネル部分のコードは1万行未満だ。
      Linuxカーネルのような巨大なモノリシックカーネルを自作してみようというのは途方もない話だが、
      マイクロカーネルならば短い期間でゼロからでも完成させることができるはずだ。
      実は私は去年ついに大学院を卒業して会社員になり、（あるいはなってしまい、）無事自由時間が今までの7分の2に減ってしまった！
      だから短い期間で完成させたいというのは実に切実な願いで、そのために作るカーネルとしてマイクロカーネルを選んだのは自然なことだったわけだ。
    }
    +p {
      そして、もう一つの理由は、L4マイクロカーネルファミリーという有名なマイクロカーネルの仕様が存在すること。
      実装するべき完成図がはっきりしているから学びながら開発していくのに都合がいいし、しかも無事仕様をみたせたときには自作したカーネルのうえで、
      既存のユーザーランドアプリケーションが動作することになる。
      OSを自作するとき、こんなに嬉しいことはないだろう！
      小さな労力でこれを達成したら、あとはサーバーなどの自分のユーザーランドをインクリメンタルに開発してゆくことも可能だ。
      L4マイクロカーネルは実世界で使われた実績もあってまだ活発に開発・研究がされている。そして今回扱うL4 X.2 APIのいいところは、
      何と言ったってシステムコールが12個しかないことだ。そう聞いたらなおさら短期間で作れそうな気がしてこないかい？
      仕様があるってことに加えて、しかもその仕様が小さいわけだ。これは一つ目の理由をさらに強いものにしてくれるね。
    }
    +p {
      色々と説明したけれど、つまりはマイクロカーネルは自作をするにはピッタリだってこと！
      そんなわけで、私は今からRustでマイクロカーネルを書き始める、というわけだ。
    }

    +subsubsection{前提知識} <
      +p {
        さて、この記事を読むにあたって前提とする知識がわりとある。
        一つめ。
        オペレーティングシステムの開発に関するベーシックな理解。
        オペレーティングシステムの基本的な概念 -例えばカーネルとかデバイスドライバ、プロセスとかいったもの- 
        について、実際に自分でゼロから書いて見たことはなくていいから、だいたいの仕組みのイメージがわくことは前提としたい。
        つまりは学部の実験レベルの知識だ。
        本当は普通のWebプログラミング経験があれば十分、ということにしたかったんだけれど、残念ながら私の原稿の速度と締め切りがそれを許さなかった！
        本文中で、C言語のコード、Makefile、それにリンカスクリプトだとかが簡単な説明だけで出てくることになる。
        ただし詳細な説明こそはしないが、Wikipediaの一段落目に出てきそうな説明文くらいは書く元気はあるから、
        そういう大学時代の知識の記憶が怪しい人や、大学時代の記憶がたまたままだないって人も、ある程度安心してほしい。
      }
      +p {
        そして二つめ。
        さらに、Rust言語のチュートリアル程度の知識。
        残念ながら、この記事ではRust言語の文法や所有権など基本的な概念の入門まではカバーしない予定だ。
        でもチュートリアルをやったことがあるというだけで十分。
        なぜかって？私がそうだから！私のRust経験はまだチュートリアルを終わらせたことと簡単な2つのプログラムを書いたことしかない。
        ただしこの記事では、必要になる知識をあらかじめ系統的に章立てして、天下り的に読者の皆さまに説明していくことは\emph{しない}。
        そうではなくて、12日間という期間でマイクロカーネルを実際に私がstep by stepで実装し、その過程を綴っていく。
        そして、開発に必要になることや私が経験したトラブルを読者の皆さんと共有する。
        だから、低レイヤ開発で必要になるRustの知識、それに単にRust初心者がぶつかるよくある問題なんかもカバーしていけるだろう。
        (私が体を張ることによってね。)
      }
      +p {
        基本的には、この記事はマイクロカーネルを作るための体系だった教科書であるよりかは、私のマイクロカーネル開発の日記により近いものとなる予定だ。
        私が実際に開発した際に（若干）読者の皆様を意識しながらそのログを残し、それにたいして抜け落ちている説明を後から書き加える形にする（予定）。
        だからきっと、このシリーズは読者の皆様が実際にRustでマイクロカーネルを作り上げてみるのにはピッタリなものとなるに違いない。
        ぜひ読者の皆様も、私の12日間を文章で追体験するだけでなく、1日ずつコードを書いていき、
        マイクロカーネルをゼロから作り上げるエキサイティングな12日間を実際に過ごしてほしい。
        それでは、早速私(達の)開発1日目を始めよう。
      }
    >
  >

  +section{1st day: L4 Microkernel} <
    +p {
      記念すべき第1日は、L4マイクロカーネルに関する概念の整理だ。
      普通のカーネルと違って、マイクロカーネルは普段LinuxやmacOSで開発を行っていては、あまりなじみがなくても仕方がない。
      \footnote{
        Windowsに触れると話はややこしくなる。
        Windowsはマイクロカーネルの要素が色濃く残っているのだ。だから少なくともしばらくはWindowsの話はしない。
      }
      そこで1日目では、具体的な目標であるL4の仕様についての話を始める前に、マイクロカーネルの概念についても整理しようと思う。
      そして最後に、実際にL4 X.2の実装であるPistachioカーネルをビルドして、Qemu上で動かしてみる。
      そうすれば、明日以降私が何を作ればいいのかがはっきりするだろう。
    }

    +subsection{What is Microkernel?} <
      +p {
        早速だが、マイクロカーネルとは何だろう？ひと段落で言えばだいたい次のようになる。
      }
      +code(`
        マイクロカーネル（英: microkernel）とはオペレーティングシステムの設計思想、及びそのようなOSのカーネル部の名称である。
        OSが担う各種機能のうち、必要最小限のみをカーネル空間に残し、残りをユーザーレベルに移すことで全体の設計が簡素化でき、結果的にカスタマイズ性が向上し、性能も向上できるというOSの設計手法のことである。
        カーネル本体が小規模な機能に限定されるので「マイクロカーネル」と呼ばれるが、必ずしも小さなOSを構成するとは限らない。 
      `);
      +p {
        以上、Wikipedia日本語版\cite[`microkernel_wikipedia`];からの引用だ。
        Wikipediaの一段落目に出てきそうな説明文くらいは書くといったが、その約束を早速果たしてしまった。
        ちなみに、マイクロカーネルの対義語にあたる、普通のカーネルの呼び名はモノリシックカーネルという。
        Linuxカーネルはこのモノリシックカーネルの典型的な例だ。
        とはいっても、これだけじゃ何が何だかという感じだろうし、重要な特徴をかいつまんで説明していこう。
      }

      +subsubsection{極小性} <

        +p {
          まず、重要なことは、さっきの引用で説明されているように、カーネルには必要最小限の機能のみがあるということだ。
          カーネル空間では、CPUの特権命令を発行する必要があるような、本当にプリミティブな機能だけが動く。
          そして、それ以上の機能は、ユーザー空間で動くプロセスが、そのプリミティブな機能をシステムコールとして使うことで実現していく。
          これらのユーザー空間のプロセスはマイクロカーネルの世界では、「サーバー」と呼ばれる。
          L4カーネルを例にとれば、カーネル空間で動く機能はおおまかに次の5つだけとなる。
        }
        +enumerate {
          * スレッドプリミティブ
          * スケジューリング
          * メモリ空間の制御
          * IPC
          * 割り込み制御
        }
        +p {
          もしかしたら、一見カーネル空間が担う機能としては普通のリストに見えるかもしれない。
          だから、普通のLinuxやmacOSのカーネル空間には存在しているけれど、このリストでは実は欠けているものをいくつか挙げてみよう。
          まず、真っ先に気づきやすいのはデバイスドライバがリストにないことだ。
          マイクロカーネルアーキテクチャでは、デバイスドライバはユーザー空間で実現される。
          最近のLinuxで提供されている、User space I/Oにあたるものがマイクロカーネルからデバイスドライバに提供され、
          デバイスドライバはユーザー空間にいながら特定の許可されたメモリ空間やIOポートをたたくことでデバイス管理を実現する。
          これにより、マイクロカーネルではデバイスドライバがクラッシュしたとして、ほかのユーザー空間プロセスに影響を与えることはないわけだ。
          ファイルシステムもデバイスドライバと似たような方法でユーザー空間に移されている。
        }
        +p {
          欠けているものその2として挙げたいのは、プロセス管理機構。
          一見すると、あれ、それは(1)で実現されているんじゃ？と思うかもね。でも実はそういうわけじゃない。
          L4でいうスレッドとは、レジスタの値とメモリ空間の組を保存したもの、くらいの意味合いしかない。
          これもそれだけ聞くと普通そんなものなんじゃ？と思ってしまうだろうから、モノリシックカーネルではプロセス管理のためにもっとどんな機能があるか思い出そう。
        }
        +p {
          分かりやすいのはプロセスの起動だろう。
          \code(`execve`);システムコールは、POSIX OSでプロセスを起動するためのシステムコールだとざっくり言ってしまってもいいと思うが、
          （おっと、あなたが顔をしかめるのが目に浮かぶようだ！でもforkやexecの話は今は本質じゃないから先にすすませてくれ。）
          このシステムコールの第一引数は起動したい実行ファイルのパスだ。
          例えばmacOSでは、ここにMach-Oフォーマットのファイルへのパスが渡される。
          すると、カーネルは、あたらしいスレッドプリミティブを作成し、Mach-Oをパースしてそのスレッドのメモリ空間に展開してくれるわけだ。
          一方、L4のシステムコールではそこまでやってくれない。
          そもそもファイルシステムはカーネルにないし、ファイルシステムを用意してあげたとして、Mach-Oをパースするのはユーザー空間の役割だ。
          L4のカーネルがやってくれるのは、単に空のメモリ空間と空のレジスタを持ったスケジュール可能なスレッドプリミティブを作ることだけ。
          それ以外のすべてはユーザー空間に実装されたサーバーの役割だ。
          例えばプロセスが開いているファイルハンドルの管理、プロセスの実行ユーザーや実行グループの管理といった機能もすべて同様にL4カーネルには欠けている。
          L4のスレッドプリミティブを呼ぶだけでは、いわゆるプロセスらしいことは何も実現できないってことだ。
        }
        +p {
          このように色々な機能がユーザー空間のサーバーの役割とされて、カーネルは最小の機能だけを実現することになっているのが、「マイクロカーネル」と呼ばれる理由だろう。
          これにより、カーネルのサイズはとても小さいものになる。
          それに、それぞれのサーバーはメモリ空間が分離されているから、デバイスドライバについての説明で話したように、一つ一つがクラッシュしても、
          その影響を最小限に抑えることができ、堅牢性も向上する。
        }
      >

      +subsubsection{OSパーソナリティ} <

        +p {
          じゃあ、そんな最小限なカーネルを使ってしまったら、いったいどうやって全体としてLinuxみたいなオペレーティングシステムを実現するのかって？
          一言でいえば、そういうマイクロカーネルに足りない部分を管理するサーバーを一つ作る、というのが答えだ。
          普通のカーネルに必要なもろもろの機能を実現するこのサーバーは、OSパーソナリティと呼ばれることがある。
          OSパーソナリティサーバーが、ファイルシステムやデバイスドライバをIPCを通じて制御し、それをもとにPOSIXのforkやread, writeのようなユーザーアプリケーションから
          見えるシステムコールを実装して一つのオペレーティングシステムを実現する、というのがマイクロカーネルベースのオペレーティングシステムの一つの形だ。
        }
        +p {
          マイクロカーネルの面白いところは、このパーソナリティサーバーを取り換えることで同じマイクロカーネルでも違うオペレーティングシステムを実現できることだ。
          L4の上でLinuxパーソナリティを走らせれば、Linuxのアプリケーションが動くし、
          (仮にあるとすればだが)macOSパーソナリティを走らせればmacOSのアプリケーションが動く。
          おまけにパーソナリティはユーザー空間のサーバーだから、同時にいくつも並行して走らせることができる。
          \footnote{まるでハイパーバイザみたいな話だが、実際マイクロカーネルは現代の仮想化機構と共通点が多い。}
          マイクロカーネルとパーソナリティの試みは、面白い具体例が色々ある。
          Fiasco.OC L4カーネル上でLinuxが動くL4 Linux\cite[`l4linux`];。
          これは今も開発が活発に続いている。何しろFiasco.OCは商用L4マイクロカーネルだ。
          過去の例でいえば、MinixがL4Ka上で動くMinix/L4\cite[`l4minix`];、Machカーネル上でLinuxが動くMkLinux\cite[`mklinux`];、それに同じくMach上で動くOSであるGNU Hurd\cite[`hurd`];.
          他にも色々あるから、探してみるのもいいんじゃないだろうか。
        }
        +p {
          この面白い特徴から、一度あるマイクロカーネルの互換カーネルを作ってしまえば、
          その上でそのマイクロカーネル用のOSパーソナリティやサーバー群が動くことになる！
          これがIntroductionで説明した自作カーネルを既存のマイクロカーネルの仕様に準拠させるモチベーションの一つだ。
        }

      >
    >

    +subsection{L4 Microkernel} <
      +p {
        さて、これでマイクロカーネルの一般的な概念の紹介はおしまいだ。
        まぁ覚えていてほしいことは、マイクロカーネルは小さな機能だけで構成されていること。
        それに、通常のオペレーティングシステムとしての機能は、マイクロカーネルの上で動くOSパーソナリティで実現されることだ。
        この節からは、L4マイクロカーネルについての話を始めよう。
      }
      +p {
        L4は、先ほど説明したマイクロカーネルアーキテクチャに基づくマイクロカーネルの一つだ。
        L4と呼ばれるマイクロカーネル実装は複数あるから、きちんと呼ぶなら「L4マイクロカーネルファミリー」になる。
        このファミリーというのは、だいたい「Windowsファミリー」と同じくらいの感覚だ。
        Windowsには95系とNT系があるわけだけど、どちらもWindowsカーネルと呼ばれるし、それぞれでもバージョン毎にだいぶ違いがある。
        つまり、ファミリーとは一つの実装を指しているわけではなく、共通の系譜を継いだお仲間たちだというわけだね。
        そして、L4マイクロカーネルファミリーの系譜の起源は、Jochen Liedtke先生による1993年の、ずばり「L4」だ。\cite[`l4`];
        \footnote{L3というL4の前身のカーネルもある。そして正確にはそちらが起源なのだが、説明を簡単にするためL4から始めたい。}
        L4を起源とするL4ファミリーの系譜の図をWikipediaから\ref-figure(`fig:l4family`);に引用した。
        論文 "From L3 to seL4 - What Have We Learnt in 20 Years of L4 Microkernels?"\cite[`l4_lessons`];は、
        L4の重要な概念がよくまとまっているうえに、この系譜図上のL4からseL4にいたるまでにL4ファミリーが解決してきた問題や、
        設計の変遷をまとめたとても良い読み物だ。
        L4についてより詳しい資料を読みたくなったら初めにこれを参照してほしい。(http://sigops.org/s/conferences/sosp/2013/papers/p133-elphinstone.pdf)
        他のL4の重要な情報源といえばずばり公式サイトであるhttp://l4hq.orgだ。
        各種L4のドキュメントや仕様がまとめられているので、こちらも初めに参照してほしい。
        つまり、両方とも外せない情報源なのでぜひ目を通してくれ。


        \figure ?:(`fig:l4family`)
          {Family tree of the L4 microkernel with time line(\cite[`l4_wikipedia`];より引用)}
          <+image-frame{\insert-image(14cm)(`../pohe/figure/L4_family_tree.jpg`);}>
      }
      +subsubsection{マイクロカーネルとパフォーマンス - L4の革命} <
        +p {
          L4の開発がはじめられたモチベーションは、マイクロカーネルが抱えていた大きな問題の解決にあった。
          その問題とは、パフォーマンスの悪さだ。
          マイクロカーネルは、その設計上IPCがボトルネックになりやすいということがよく議論にあがる。\cite[`l4_lessons`];
          マイクロカーネルでは、システムコールがサーバー間の複数のIPCで実装され、そしてIPCはコンテキストスイッチを伴う。
          一方、モノリシックカーネルのシステムコールは通常1回のコンテキストスイッチで済むから、
          比較するとマイクロカーネルではシステムコールのコストが割高になってしまう。
        }
        +p {
          L4は、Liedtkeがこの問題を解決するために開発した、画期的なマイクロカーネルだった。
          先ほど名前だけ少し出た、Mach\cite[`mach_wikipedia`];というマイクロカーネルでは、IPCのコストが顕著だった。
          \footnote{MachはMinixと並んでもっとも著名なマイクロカーネルの一つだろう。現在のmacOSのXNUカーネルの源流でもある。
          著名であるにもかかわらず、不名誉な文脈でしか触れられないことに不満を持つファンもいるだろうから、ここでその栄誉を称えておく！}
          このMachはL4の文脈では、「第1世代マイクロカーネル」として言及される。もちろん、L4が第2世代だという流れでだけどね\;)
          Liedtkeは、L4で極小性をキーコンセプトとしてマイクロカーネルをデザインしなおした。
          IPCの機構はMachに比べて極端に単純になり、メッセージサイズも小さくなりCPUのキャッシュになるべくすべてのメッセージが載るように設計した。
          スケジューリングなども単純化され、さらにはカーネルすべてをアセンブリで書いてしまうというものすごい執念でありうる極小のマイクロカーネルを完成させた。
          結果はどうなったと思う？なんとIPCはMachに比べて20倍も高速化したのだ！\cite[`l4_wikipedia`];
          ちなみに、のちにL4カーネルはCやC++で書き直されたが、パフォーマンスは悪化しなかったので安心してほしい。
          さらに後続の研究では、LinuxパーソナリティがL4上で実装され、本物のLinuxカーネルに比べても数パーセントのオーバーヘッドしか発生しないことが示された。\cite[`l4_lessons`];
          こうしてL4により、マイクロカーネルは実用的なオーバーヘッドで実現できるということが示されたのだ。
        }
      >
      +subsubsection{マイクロカーネルの逆襲} <
        +p {
          L4の登場以降、マイクロカーネルは様々な方向に発展している。
          MINIXのタネンバウム教授が2016年に"Lessons learned from 30 years of Minix"で述べているように、
          L4ベースのマイクロカーネルはほとんどあらゆるiPhoneのセキュリティチップで動いているし、QNXは色々な組み込み機器で実用化されている。
          こいういう機器では、少々の性能のオーバーヘッドよりも信頼性が重要だからだ。\cite[`minix_lessons`];
          そのタネンバウム先生のMINIX自身も、実は世界中のIntel x86 CPUで動いていたという事実が最近判明した。\cite[`intel_minix`];
        }
        +p {
          マイクロカーネルの発展は実用化方面だけではない。
          一番クールなプロダクトはやはりseL4だろう。\cite[`sel4_web`];
          seL4は、マイクロカーネルのコードサイズが小さいことを利用して、その正当性をIsabellaで証明したおそらく世界で唯一のカーネルだ。
          メモリ安全性といった一般的な性質や、ポートベースのポリシーシステムが決して違反されないことなどを数学的に証明している。\cite[`sel4_web_faq`];
          しかもseL4はそのAPI設計自体もかなりシンプルで良い感じだ。
          実際、今回実装する仕様の対象としてseL4はかなり有力な候補だった。しかし、仕様の大きさの問題でこの記事ではseL4を選ばなかった。
          また、seL4のAPIのそれ以前のL4ファミリーの共通点はほとんどないことも注意事項かもしれない。思想上の家族、といったところなのかもね。
        }
        +p {
          普段Linuxの世界で生きていると、1992年、つまりL4発表の前年のリーナスとタネンバウム先生\cite[`linus_tan`];の論争から
          マイクロカーネルの時は止まっているかのように思えてしまうものだ。
          しかしL4以降、マイクロカーネルのパフォーマンスは大幅に改善した。
          実用化という面では、QNX, MINIX, L4の数を足してみれば、もしかすると実はLinuxよりも多くの数のマイクロカーネルが世界では動いている可能性すらある。
          証明済みカーネルというユニークな成果も、マイクロカーネルでなければ不可能だったものだ。
          あまり大きくは知られていないけれど、マイクロカーネルの世界はどんどん発展していて、いつの間にか「逆襲」を果たしていたというわけかもね。
        }
      >
    >

    +subsection{Let's boot L4 Pistachio in Qemu} <
      +p {
        少しおしゃべりが過ぎたようだ。
        そろそろ作業の方に入った方がいいだろうね！
        私はこれからL4の互換マイクロカーネルをRustで書いていくわけだが、今の話で分かるようにL4と一言で言ってみてもまぁ色々なやつがいるわけだ。
        じゃあ何を作ろうかと考えて決めた結論は、\ref-figure(`fig:l4family`);のど真ん中あたりに陣取っている\code(`Pistachio`);だ！
      }
      +subsubsection {L4 Pistachio} <
        +p {
          Pistachioを選んだ理由は、一言でいって、短期間で自作するのにぴったりだから、だ。
          系譜図で紹介したように、L4にはたくさん実装があるのだけれど、そのうちいくつかの実装は、
          「L4マイクロカーネルの標準API仕様」に準拠して実装されている。
          マイクロカーネルのAPI仕様、といわれてもピンとこないかもしれないが、要はPOSIXと似たようなもので、カーネルが実装しているシステムコール、
          そのシステムコールの呼び出しABIなどが定義されている。
          割り込みが起きたときにどのようなプロトコルで処理が走るべきか、なんかも定義されているのは少しカーネルらしいところかもしれない。
          そして、Pistachioは、きちんと定義された最後の仕様といっていい、L4 X.2 APIというものに準拠している実装なのだ。
          L4 X.2 APIはシステムコールが12個しかないというとても小さい仕様になっていて、準拠したマイクロカーネルを実装しやすい。
          ちなみにこの記事が12日でカーネルを作る、と言い張っているのはこのAPIが12個しかない、ということを根拠にしている。
          \footnote{まだ実装はさっぱり終わってないから、正直これは私の希望でしかないんだけどね！}
          X.2以降のおおよそ似たようなL4ファミリーといえばOKL4とFiasco.OCになるのだが、これらはどちらも実用的なマイクロカーネルとなっていて、
          アカデミアの世界で完結しているX.2に比べ実装されているAPIがとても多く、互換カーネルを作るのが困難だ。
          それにそもそもこれらのカーネルは、もはやきちんと定義された仕様が存在しない。
          一方seL4は、実用性も兼ねているにもかかわらずきちんと定義された仕様が存在するのだが、やはりX.2に比べるとだいぶ大きな仕様になってしまっている。
          そんなわけで、最後の実質的な更新は2010年頃と少し古いけれど、互換カーネルを自作するのにピッタリの対象としては、X.2、それにPistachioが選ばれたというわけ。
          L4 X.2がどのような仕様か、ということは必要に応じて紹介していくことにして、今は早速Pistachioカーネルを動かしてみることから始めよう。
        }
      >
      +subsubsection {Pistachioのビルド} <
        +p {
          あらゆることはまず\code(`git clone`);から始めよと昔から言われているように、まずはPistachioを手元にcloneしよう。
          公式レポジトリは\code(`https://github.com/l4ka/pistachio/commits/master`);だから、早速ここからcloneしてくれ・・・と言いたいところなのだけど、
          実は私の環境だとこのレポジトリのビルドが失敗した。私の環境はUbuntu 18.04で、普通にインストールして入ってくるgccのメジャーバージョンは7だ。
          gccは5以降あたりから、Position Independent Codeをデフォルトでビルドするようにオプションが変更されていて、
          私はそれでなかなかPistachioのビルドが通らなくて痛い目を見た。
          ちょっと古めのソースコードをビルドしてみようとすると大抵こうなるものだ。\*sigh\*
          自分が経験した痛い目を、わざわざ文章で再現してもう一度痛みを確かめるような趣味は私にはないから、
          gcc 7でもビルドが通るように私が修正したものを使うように歴史を修正しながら作業過程を書いていくことにする！
          \footnote{
            ちなみにビルドが通るように修正したあとに、aptから最新のgccとは別にgcc5をインストールできることを知った。
            もしかしたらこれを使えば元のレポジトリでもビルドが通るのかもしれない。
          }
          \d-code(`
          $ git clone https://github.com/nullpo-head/pistachio.git
          `);
          これで、私がした苦労をスキップして、Ubuntu 18.04上でビルド可能なPistachioが手に入る。
          どうMakefileを変更すれば良いのかが気になる人は、このレポジトリの最新2コミットを見てほしい。
        }
        +p {
          それではビルドを始めよう。
          Pistachioに限らない話なのだが、L4は資料があるのか無いのか微妙なラインを攻めてくる。
          Pistachioのまともに完遂できるビルド方法に関しても、英語でも日本語でも良いものがなかなか見つからなかったのだが、幸運なことに
          n_kaneさんの記事(http://d.hatena.ne.jp/kayn_koen/20100801/1280622473)がとても参考になる。
          これをもとにビルドを進めていこう。
        }
        +p {
          まずはカーネルのビルドからだ。カーネル用のビルドディレクトリを作りつつ、カーネルをビルドしよう。
          \d-code(`
          $ cd pistachio/kernel
          $ make BUILDDIR="$(pwd)/../build-kernel"
          `);
          n_kaneさんいわく、BUILDDIRは絶対パスである必要があるとのことだ。
          \d-code(`
          $ cd ../build-kernel
          $ make menuconfig
          `);
          ここでLinuxやbusyboxのビルドでおなじみのmenuconfigが表示される。
          お好みで設定を変えていくわけだけど、ここでは64bitカーネルをビルドするよう設定する。
          もう平成も終わって令和になるわけだから、今から作るカーネルはもちろん64bitカーネルだからね。
          \d-code(`
          $ make -j4
          `);
          そしてビルドする。\code(`x86-kernel`);バイナリができあがった。
        }
        +p {
          次はユーザーランドのビルドだ。同じように進めていく。
          ただし今度はautoheaderとautoconfを動かす必要がある。どうしてそんな構成になっているのかは分からないけど、まぁとにかく従ってみよう。
          \d-code(`
          $ cd ../user
          $ autoheader
          $ autoconf
          `);
          さらに今度はビルドディレクトリも自分で用意して、その中でビルドを進める。
          \d-code(`
          $ cd ..
          $ mkdir build-user
          $ cd build-user
          $ ../user/configure --prefix="$(pwd)/../install-user" --with-kerneldir="../build-kernel/"
          $ make -j4
          $ make install
          $ cp ../build-kernel/x86-kernel ../install-user/libexec/l4/
          `);
          カーネルに比べて少し複雑だけど、これでビルドが完了して、install-userディレクトリの中にもろもろの成果物が出力される。
          大事なものはだいたいl4ディレクトリ以下にまとまるようだ。
          確認してみよう。
          \d-code(`
          $ cd install-user/libexec/l4/
          $ ls
          grabmem*  kickstart*  l4test*  pingpong*  sigma0*  x86-kernel*
          `);
          That's it!
          できた成果物を、それぞれ少し説明しよう。
        }
        +listing{
          * kickstart
            これはL4のためのブートローダのようなものだ。
            GRUBなどのブートローダは一旦このkickstartを起動し、そのkickstartがx86-kernelを起動する。
            どうしてそんなことになっているかはあとでmultibootと一緒に説明しよう。
          * x86-kernel
            これがPistachioマイクロカーネルの本体だ。
          * sigma0
            これはルートページャと呼ばれる特殊なサーバーになる。
          * pingpong
            これはユーザー空間のサーバーで、Pistachio上で動くユーザーアプリケーションだと言ってもいい。
            ただし、sigma0の次に動かすことを想定しているから、OSパーソナリティサーバーなしに動くユーザーアプリケーションだね。
            といっても、L4は組み込みの世界でよく使われるから、汎用のOSパーソナリティなしにアプリケーションが動く状況は珍しくないはずだ。
            pingpongは、いくつかのプロセスを立ち上げ、互いにIPCを送り合うことで、マイクロカーネルの性能を測定する動作をする。
          * l4test
            こちらもユーザーアプリケーションだ。pingpongがIPCをするものだったのに対し、l4testはL4のAPIに対する広範なテストを動かすものだ。
          * grabmem
            気にしなくていい。
        }
        +p {
          というわけで、これらがPistachioレポジトリをビルドして得られたものだ。
          せっかくビルドしたんだから、じっと睨んでいても仕方がない。Qemu上で起動してみよう。
        }
      >
      +subsubsection {Multibootを使ってQemuでブートさせる} <
        +p {
          さっきビルドしたバイナリ群は、すべて"Multiboot"という仕様に準拠したバイナリになっている。
          読者の皆さまの中で、UNIX系の自作OSに挑戦したことがある人は知っているかもしれないね。
          CPUやプラットフォームによって、OSのブートプロセスというのは異なるものだ。
          だから、OSが色んなプラットフォームに対応しようと思えば、すべてのプラットフォーム上でブートローダーを書く必要がある。
          逆にOS自体も色々なものがあるわけで、
          あるブートローダーが色々なOSをブートできるようにしようと思うと、OSの数だけブートローダーからOSに処理を渡すコードを書く必要がある。
          つまり、色々なOSが色々なプラットフォームで動くための色々なブートローダーが乱造されることになるわけだ。
          これはとても非効率だし、開発者もできればそんなことはやりたくない。
          この問題を解決するために提案されたのがMultiboot仕様だ。\cite[`multiboot1`];
          これに準拠さえしていれば、この面倒くさい問題を回避できるようになる。
          あらゆるMultiboot準拠のブートローダーは、あらゆるMultiboot準拠のオペレーティングシステムを起動できるのだ。
          しかもMultiboot仕様では、ブートローダーがCPUの初期化の面倒くさいところをやってくれることになっているので、
          Multiboot準拠のカーネルを書けばx86プロセッサの面倒くさいブートプロセスなんかをスキップすることができる。
          私がカーネルを書くときは、必ずMultiboot準拠にしてこの恩恵にあずかることにしている。
          OS側としてMultibootに準拠するのに必要なことは、Multibootヘッダと呼ばれるものをカーネルの先頭にくっつけ、カーネルバイナリのフォーマットをELFにするだけなので実に簡単だ。
        }
        +p {
          n_kaneさんの記事ではGRUBを使ってPistachioをブートしていたが、実はQemuにはMultibootのバージョン1仕様のブートローダーが組み込まれている。
          だから、Qemuで直接Pisachioを起動することができる。やっていこう。
          \d-code(`
          $ qemu-system-x86_64 -kernel kickstart -initrd x86-kernel,sigma0,pingpong
          `);
          すると\ref-figure(`fig:booting`);のような画面が表示される。
          \figure ?:(`fig:booting`)
            {Pistachioがブートする様子}
            <+image-frame{\insert-image(14cm)(`../pohe/figure/booting.JPG`);}>
          これはPistachioがブートしている途中の画面だ！
        }
        +p {
          qemuに渡したコマンドラインオプションを解説すると、\code(`-kernel`);がまずMultibootブートローダーが最初に起動すべきバイナリを渡すものだ。
          Pistachioの場合、ここに一旦\code(`kickstart`);を渡すことになる。
          qemuにはさらに、\code(`-initrd`);オプションで、\code(`x86-kernel,sigma0,pingpong`);を渡している。
          \code(`kickstart`);はこれのELFフォーマットをパースして、x86-kernelに教えてくれる役割を果たしている。
          その後、本体の\code(`x86-kernel`);に処理が渡される。
          ちなみに豆知識なんだけれど、そもそもMultibootはMachやL4のようなマイクロカーネルを起動するためのブートローダーとしても想定されているらしい。
          \code(`-initrd`);オプションで渡しているものは「ブートモジュール」とMultibootでは呼ばれる。
          マイクロカーネルは普通、カーネル自身にファイルシステムや複雑なELFローダーがないことが多いので、
          ブートローダーがあらかじめ起動に必要なバイナリ群をメモリ上に展開しておき、マイクロカーネルに処理を渡す、というのがモチベーションだ。
          その構造は、しっかりPistachioでも活かされている。
        }
        +p {
          さて、\ref-figure(`fig:booting`);は確かにブート途中の画面なんだけれど、実は処理が進んでもここから動かない。
          今回アプリケーションとして起動しているpingpongの出力は、VGAじゃなくてシリアル経由でしか表示されないからだ。
          オプションを変えて起動しなおしてみる。
          \d-code(`
          $ qemu-system-x86_64 -nographic -kernel kickstart -initrd x86-kernel,sigma0,pingpong
          `);
          すると、下のようにpingpongの出力がターミナルに表示された。
          \d-code(`
            Launching kernel ...
            entry: 0xd0e000

            L4Ka::Pistachio - built on Apr  2 2019 01:51:37 by nullpo@Surface-EPJH0U2 using gcc version 7.3.0
            Pingpong started 1

            Please select ipc type:

            1: INTER-AS
            2: INTRA-AS (IPC)
            3: INTRA-AS (LIPC)
            4: XCPU
            a: architecture specific
            s: print SQLite table
            Benchmarking Intra-AS IPC...
            IPC ( 0 MRs): 2131.71 cycles, 0.79us, 0.00 instrs
            IPC ( 1 MRs): 1720.19 cycles, 0.68us, 0.00 instrs
            ...
          `);
        }
        +p {
          これで無事、ビルドしたPistachioが起動したことになる！
          そしてユーザー空間のアプリケーションとしてpingpongを動かしてみた。
          もっと派手な見た目が動くGenodeみたいなものもあるんだけど、説明がややこしくなるから標準バンドルのpingpongだけに話をしぼらせてもらった。
          時間があれば、xv6をPistachio上に移植したり、Minix OSパーソナリティをL4上に実装したりして、マイクロカーネルの実装が終わったときに
          かっこいい見た目のOSが動くようにしたいものだ。
          でもまずはこの地味なpingpongが第1歩！これが偉大な一歩かは知らないが、少なくとも結構頑張った1日目にはなったんじゃないかな。
        }
      >
    >
  >

  +section{2nd Day: Writing a Minimal Kernel in Rust} <
    +p {
      昨日の1日目では、マイクロカーネルの概念とL4マイクロカーネルの話を学び、実際にPistachioカーネルをQemu上で動作させてみた。
      今日からは、ありもののカーネルを動かすのではなく、自分の手でL4マイクロカーネルの実装を始めることにする。
      その第一歩として今日は、Rustでベアメタルプログラミングに挑戦し、自作の最小のカーネルをQemu上で動かしてみよう。
      今日の目的は、一旦マイクロカーネルのことは忘れ、Rustでのベアメタル開発の世界に飛び込んでみることだ。
      以降の章で、今日作るカーネルをもとにして少しずつマイクロカーネルを作りあげていくことになる。
      さて、ふだんはWebプログラムなどの開発を行っていて、低レイヤでのプログラミングにはなじみがないが、ここまで読み進めた方もいないとは限らない。
      この記事では基本的な低レイヤプログラミングの基礎知識を1ステップずつ網羅していくようなことは、できない。
      \footnote{締切の都合で}
      しかし、実際に手を動かして試してみて、低レイヤプログラミングの楽しさを知ってもらえたとしたらこれほど嬉しいことはない。
    }
    +p {
      一方、ここまで読んでいるような読者の方は、おおよそ、この手のプログラミングにはもう慣れっこだろう。
      私自身、こういうプログラムを書くのは初めてではない。
      Xv6という小さなUNIXライクなオペレーティングシステムをMIPSアーキテクチャに移植したことがあるし、
      それを自分たちで設計・FPGA上に実装したオリジナルCPUに移植したこともある。
      また、CPUの仮想化支援機構を利用して既存のオペレーティングシステムにLinuxパーソナリティを実現するNoahというソフトウェアを作ったことがある。
      このマイクロカーネルと似たような話の開発では、かなりの時間を仮想環境内のベアメタルプログラミングに費やした。
      だけどこのような低レイヤプログラミングに慣れっこだというのは、あくまで「C言語を使う限りにおいては」だ。
      だから、Rustでカーネルを書くと何が楽になり、何が独特の難しさかといった点が重要なポイントだろう。
      C言語でならこの手のプログラミングに慣れているという方は、
      いつもの慣れた手順がRustの世界ではどのように様変わりするのかということを楽しんでもらえると嬉しい。
    }

    +subsection{Bare Metal Programming} <
      +p {
        さて、いよいよRustでのベアメタルプログラミングの世界に飛び込んでみる時がきた。
        実はRustの世界ではすでに、"Writing an OS in Rust" (https://os.phil-opp.com/)という素晴らしいWebシリーズが存在する。
        このシリーズは、Rustでベアメタルプログラミングをするための準備から、x86アーキテクチャの基礎知識までカバーしている素晴らしいシリーズだ。
        Rustでオペレーティングシステムを書くなら、これをチェックしない手はない。
        私も今日Rustで小さなカーネルを書いてみるにあたって、このシリーズのお世話になることにした。
        実のところ、私がこの記事を、教科書のようなスタイルではなく私の個人的なカーネル開発のログを時系列で綴っていくスタイルにしようと思ったのも
        このシリーズの存在が理由だ。
        すでに素晴らしい教科書が存在するというのに、そこに不完全なものを新たに一つ加えたところで何になるだろう！
        (ただし"Writing an OS in Rust"は2019年1月時点ではまだ未完結で、ページングに関する解説が執筆されているところであることには注意してほしい。
        だが、活発に執筆が続けられているので、すぐに完結することだろう。
        )さて、早速"Writing an OS in Rust"の第1章、"A Freestanding Rust Binary"に従って、Rustでのベアメタルプログラミングに入門してみることにしよう。
        "Writing an OS in Rust"は主にPhilipp Oppermann氏によって執筆されている。
        これから毎度毎度"Writing an OS in Rust"とフルタイトルと呼ぶのは、書くのも読むのも大変だから、"Philipp's"と呼んでいくことにしよう。

      }

      +p {
        まずは、Rustのツールチェインの準備からだ。
        Philipp'sで説明されているところによると、Rustでオペレーティングシステムを作るにあたっては、nightlyコンパイラがまだ必要らしい。
        私はRustに触れたのが比較的最近なので、RustツールチェインのインストールにはきちんとRustupツールを使っている。
        その場合は下記のコマンドでnightlyコンパイラを簡単にインストールすることができる。
        もし、Rustに触れてみたのがかなり昔で、RustツールチェインのインストールにRustupを使わなかったという読者の方は、
        Rustupを使ってツールチェインをインストールしなおすのがいいだろう。
      }

      +p {
        \d-code(`$ rustup install nightly`);

        これでRustツールチェインの準備は完了だ。シンプル！
        さて、ここでこれから、自分がカーネルを書いていくことになるRustプロジェクトを初期化しておく。
        これはこのプロジェクトに名前を付けるということでもある。
        これから作っていくカーネルは、最終的にはL4マイクロカーネルファミリーのマイクロカーネルになる。
        Rust製のL4カーネル実装はたぶん私のものが初めてになるだろうから、それにふさわしい名前として、
        私は自分のカーネルを\code(`Rusty L4`);と呼ぶことにした。
        だから、ここで私が走らせるコマンドはこうだ。

        \d-code(`
          $ cargo new rusty_l4 --bin --edition 2018
        `);
      }

      +p {
        cargoコマンドの使い方は覚えているだろうか？念のためおさらいしておくとcargoコマンドはRust標準のビルドツールだ。
        Rustのプロジェクトは基本的にcargoコマンドを使って管理していく。
        \code(`--edition 2018`);は見慣れないオプションだ。
        これは2018年ギリギリにリリースされたばかりのRust 2018の機能を有効にするためのオプションである。
        Rust 2018は多くの便利な新機能が導入されたエキサイティングなバージョンだ。
        特にこだわりがなければこれを使わない手はない。
      }

      +p {
        さらに、Philipp'sにしたがって、Rusty L4のプロジェクトではnightlyコンパイラをデフォルトで使用するように設定する。

        \d-code(`$ rustup override add nightly`);
      }

      +subsubsection {no_std} <
        +p {
          C言語では、以下のコードに対して、
          \d-code(`
            int _start() {
              for(;;);
            }
          `);
          \d-code(`gcc loop.c -nostdlib`);
          のようなコマンドをたたくと、OSに依存しない、起動後ひたすら無限ループをするELF実行ファイルを作成することができる。
          ELFが正しくロードされる環境なら、大抵の場所で動くだろう。
          \code(`_start`);は、ELF実行ファイル、つまりLinuxでの標準的な実行ファイルがOSから初めて起動されるときに読み込まれるエントリーポイントだ。
          通常のCプログラムでは、_startは標準ライブラリによって実装されていて、初期化処理を経た後\code(`main`);が呼ばれることになる。
          こういうレイヤの低いことを簡単にできるのがCの強みだ。
        }
        +p {
          これをRustで実現するにはどうすればいいだろうか？
          Philipp'sによれば、\code(`#![no_std]`);アトリビュートの出番だ。
          これは、C言語での\code(`-nostdlib`);オプションに相当する概念だ。
          ただし、単にこのアトリビュートをファイルの先頭に書くだけではうまくいかない。
          Philipp'sに従って開発を進めると、先ほどのCプログラムにあたるコードは次のようになる。

          \d-code(`
            // main.rs

            #![no_std] // don't link the Rust standard library
            #![no_main] // disable all Rust-level entry points

            use core::panic::PanicInfo;

            #[no_mangle] // don't mangle the name of this function
            pub extern "C" fn _start() -> ! {
                loop {}
            }

            /// This function is called on panic.
            #[panic_handler]
            fn panic(_info: &PanicInfo) -> ! {
              loop {}
            }
          `);

          そして、\code(`Cargo.toml`);にはこう記述しよう。

          \d-code(`
            [package]
            name = "rusty_l4"
            version = "0.1.0"
            authors = ["FOO BAR <foo@bar.com>"]
            edition = "2018"

            [profile.dev]
            panic = "abort"

            [profile.release]
            panic = "abort"
          `);

          この状態から、Linux上では以下のコマンドでビルドが成功する。
          \d-code(`$ cargo rustc -- -C link-arg=-nostartfiles`);
          macOS上では別のコマンドが必要なのでPhilipp'sを参照してほしい。
          もっともmacOS上ではstaticバイナリの実現は難しいのだけれど。

          C言語に比べて増えたことは、だいたい次の二つだった。
          \listing {
            * panicの処理を自分で書いたこと、そしてpanicのためのstack unwindingを無効にしたこと。
              Rustでは、ベアメタル環境でも配列の境界チェックなどでpanicが発生する。そのためのハンドラを与えてやる必要がある。
              それにC++の例外のようにstack unwindingが存在するから、それを無効化する必要がある。
              でもこれは、tomlにpanicの設定を書くだけで無効化ができるんだから、かなり簡単な方だと思う。
            * \code(`#[no_mangle]`);を与える必要があること。これまたC++と同じで、Rustでも関数名がバイナリレベルではソースコード上と一致しない。
              同じ名前のシンボルでも、名前空間が違えば区別する必要があるから、その手の情報を名前に埋め込むのだ。これをmanglingと呼ぶ。
              \code(`#[no_mangle]`);で\code(`_start`);に対してマングリングを無効化している。
          }
        }
      >

    >

    +subsection{Minimal Rust Kernel} <
      +p {
        ここまでで、Rustでベアメタルプログラミングに挑戦してみて、C言語との違いについて述べてきた。
        いまのところ、いくつか違いはあるけれど、Cでもできたことがよりイマドキな書き方でできるんだな、というくらいの感想を持っているかもしれない。
        むしろ、色々とベアメタルでは使えなくなってしまう言語機能の穴埋めに奔走させられた気すらしているかも。
        しかし、イマドキの言語でベアメタルプログラミングをする便利さを実感させられたのはここからだった。
        急に開発スピードが加速していくから注意してついてきてほしい。
      }

      +subsubsection{ビルド設定} <
        +p {
          ただのno_stdプログラムをビルドするのではなく、今からはオペレーティングシステムがなくても動くようなプログラムをビルドすることになる。
          そのために、Target Specificationというものを書く必要がある。
          これはjsonファイル形式のファイルで、cargoのビルドを細かく制御することができる。

          \d-code(`
            {
              "llvm-target": "x86_64-unknown-none",
              "data-layout": "e-m:e-i64:64-f80:128-n8:16:32:64-S128",
              "arch": "x86_64",
              "target-endian": "little",
              "target-pointer-width": "64",
              "target-c-int-width": "32",
              "os": "none",
              "executables": true,
              "linker-flavor": "ld.lld",
              "linker": "rust-lld",
              "panic-strategy": "abort",
              "disable-redzone": true,
              "features": "-mmx,-sse,+soft-float"
            }
          `);

          これを\code(`x86_64-rusty_l4.json`);という名前で保存した。
          各フィールドの意味はなんとなく類推できるんじゃないだろうか。注目すべきはosがnoneになっていること。
          あと、若干脇にそれるけれど、\code(`"disabel-redzone": true,`);を指定していること。
          redzoneはx64で初めて登場した、32 bit時代にはなかった概念だ。
          コンパイラの最適化のために、一定の大きさのスタックポインタの先をふれてもいいという規約のことを指す。
          これは割り込みハンドラの処理と相性が悪いから、カーネルのコード中ではこのredzoneを無効化する必要がある。
        }
      >

      +subsubsection{cargo xbuildによるクロスコンパイル} <
        +p {
          さて、次に、このコマンドを走らせる。
          \d-code(`$ cargo install cargo-xbuild`);
        }
        +p {
          これはRustでカーネルを書き始めての初めてのcargo installだ。
          パッケージのエコシステムが整っているということは、必ずしもRustの特徴だというわけではない。
          RubyみたいなLL言語しかし、Goのようなコンパイル言語しかり、最近の言語は程度の差こそあれパッケージの管理機構を
          言語ランタイム自体と結び付けて提供している。
          しかし、カーネル開発だという文脈だと、このエコシステムは間違いなくRustの強みだ。
          CやC++言語ではこのエコシステムはきちんと育っていない。
          私は、時間の（特に締め切りの）都合でRustのcrateをどんどん使用していったのだが、
          結果としてカーネル開発がいかに楽になるかということが体感できた気がする。
        }
        +p {
          さて、\code(`cargo-xbuild`);は、Rustの標準ライブラリのサブセットである\code(`core`);ライブラリや\code(`compiler_builtins`);を
          Cargoで指定したターゲット向けにクロスコンパイルしてくれるcrateだ。
          \code(`core`);ライブラリと\code(`compiler_builtins`);ライブラリには、Rustの標準ライブラリのうち、
          ベアメタル環境でも使える機能が含まれている。
          cargo-xbuildを使わない場合、自分でこれらのライブラリをクロスコンパイルしないと、Rustらしい色々な機能が使えなくなってしまう。
          これがないと、カーネル開発が非常に不便になるというくらい、必要性が高いcrateだ。
          そしてこのcrateはPhilipp氏自身によって開発されている。
          cargo-xbuild以外に多くのcrateが出てくることになるが、そのうち大半のcrateがPhilipp氏によるものであったりする。
          カーネル開発を便利にしてくれるcrateを整備していった上で、ブログまで書いてるんだから、まるでブルドーザーみたいな人だ。
          cargo-xbuildを用いてビルドをするためには、次のコマンドでビルドを行おう。
          \d-code(`$ cargo xbuild --target x86_64-rusty_l4.json`);
        }
      >
      +subsubsection{VGAへの表示とBootimage} <
        +p {
          Philipp'sに従って、次はVGAを使って画面に文字を書く機能をmain.rsに加えてみよう。
          _start周辺を、下のコードのように書き換えよう。

          \d-code(`
            static HELLO: &[u8] = b"Hello World!";

            #[no_mangle]
            pub extern "C" fn _start() -> ! {
                let vga_buffer = 0xb8000 as *mut u8;

                for (i, &byte) in HELLO.iter().enumerate() {
                    unsafe {
                        *vga_buffer.offset(i as isize * 2) = byte;
                        *vga_buffer.offset(i as isize * 2 + 1) = 0xb;
                    }
                }

                loop {}
            }
          `);
          今回、コード中にunsafeが出現している。適当な値のポインタに書込みを行うんだから当然だ。
          これは、VGAのテキストバッファに文字を書き込むことで、Qemuのエミュレータ画面にHello Worldを表示させている。
          VGAの詳しい仕様についはPhilipp'sの解説やWikipediaを参考にしてほしい。
        }
        +p {
          さて、これをいったいどうやってQemu上で起動するのだろう？
          ただELFファイルを作るだけでは、エミュレータ上でOSとしてブートさせることはできない。
          PistachioがやっていたようにMultibootに対応するか、もしくは自前でブートローダーを作る必要があるのだ。
          そこで\code(`bootloader`); createと\code(`bootimage`);ツールの出番だ。
          このcrateは後者、Phillip氏によってピュアRust(とインラインアセンブリ)で書かれたブートローダーで、\code(`bootimage`);と組み合わせて使用する。
          bootloader crateをインストールすると、私のカーネルがbootloaderでブートできる形になり、
          bootimageツールはcargoのラッパーツールとして働いて、実際にブート可能なディスクイメージを作成してくれる。
          bootimageをインストールしよう
          \d-code(`$ cargo install bootimage --verion "^0.5.0"`);
          このコマンドはセマンティックバージョニングでの、0.5.xの最新のバージョンのbootimageをインストールする。
          そして、Cargo.tomlにbootloader crateへの依存を追加する。
          \d-code(`
            [dependencies]
            bootloader = "0.4.0"
          `);
          もっと新しいバージョンももうPublishされているのだけど、これで大丈夫だ。
          ではさっそく、bootimageコマンドを使ってカーネルをビルドしよう。
          \d-code(`$ bootimage build --target x86_64-rusty_l4.json`);
          bootimageは内部でcargo-xbuildを使ってビルドしてくれるから、coreライブラリの心配は引き続きしなくて大丈夫だ。
        }
        +p {
          さて、いったい何が起きたのか確認してみよう。
          これだけで、ブート可能なディスクイメージが生成されている。
          \d-code(`
            $ cd target/x86_64-rusty_l4/debug/
            $ ls
            bootimage-rusty_l4.bin  build/  deps/  examples/  incremental/  native/  rusty_l4*  rusty_l4.d
            $ file bootimage-rusty_l4.bin
            bootimage-rusty_l4.bin: DOS/MBR boot sector
          `);
          なんとブータブルイメージが出力されている！
          この\code(`bootimage-rusty_l4.bin`);がお目当てのものだ！
          Philipp'sでも説明されているように、bootloader + bootimageでは、
          ブートローダーのバイナリファイルの後ろに、rusty_l4のELFバイナリがくっついたものが、スタンドアローンバイナリとして生成される。
          それがBIOSによって起動され、ブートローダーはrusty_l4バイナリを適切にメモリ上に配置してブートするようになる。
          いくつかのコマンドをたたいて、crateをインストールしただけなのに！
          起動してみよう。
          \d-code(`
            $ qemu-system-x86_64 -drive format=raw,file=bootimage-rusty_l4.bin
          `);
          すると、\ref-figure(`fig:bootimage`);のように、Qemuの画面上にHello, World!が表示された。

          \figure ?:(`fig:bootimage`)
            {bootimage + bootloaderで、何も書かなくてもカーネルが起動する}
            <+image-frame{\insert-image(14cm)(`../pohe/figure/bootimage.JPG`);}>

          createにより、カーネル開発の速度がすごいぐらいに加速されている。
          OSのブートからVGA表示までがこんなに早いのは素晴らしいことだ。というか何かプログラムを書いた気がしないくらいだ。
        }
        +p {
          どんどんPhilipp'sの実装を進めていこう。
          VGAプリントのモジュールを作ることが次の目標だ。そのために必要なcrateをそろえていく。
          \code(`volatile`); crateと\code(`spin`); crateをCargo.tomlに加えよう。
          \d-code(`
            [dependencies]
            spin = "0.4.9"
            volatile = "0.2.3"
          `);
          volatileは、Cのvolatileを知っている人にとっては話が早いだろう。
          これはたとえば、
          \d-code(`
            struct Buffer {
              chars: [[Volatile<ScreenChar>; BUFFER_WIDTH]; BUFFER_HEIGHT],
            }
          `);
          のように使用する。カーネル開発では、まさにVGAのような、メモリ上の特別なアドレスへの読み書きを行って何かハードウェアとやりとりすることがある。
          しかし、これはコンパイラから見れば、意味もなくメモリを読み書きしているようにみえるので、最適化の過程でコードが消されてしまう。
          それを防ぐために、このアドレスのメモリデータは、その読み書きに外部との相互副作用がありますよ、というのを明示するのがvolatileだ。
          Rustにもこのvolatieの仕組みがあり、そしてこのvolatile crateは、それを使いやすいラッパーで隠ぺいしたPhilipp氏のcrateだ。
          一方のspinは、スピンロックによるロックを提供するためのcreateだ。
          ベアメタル環境では、標準ライブラリのMutexなどが基本的に使えない。
          しかし、このspin crateは、スピンロックを同期プリミティブとして使用したMutexを提供してくれる。
          ちなみにこちらはPhilipp氏のcrateではない。
        }
        +p {
          次に\code(`lazy_static`);をインストールしよう。これはかなり重要なcrateだ。
          Cargo.tomlに次の記述を加える。
          \d-code(`
            [dependencies.lazy_static]
            version = "1.0"
            features = ["spin_no_std"]
          `);
          Rustでは、Cのようなグローバルにアクセスできるにもかかわらず、mutableであるような変数は基本的に使えない。
          staticスコープで、かつmutableであるようなものはborrow checkerのルールを満たせない。
          このような変数は、mutableではないためにしばしば初期化が難しくなる。
          lazy staticは、そんな問題を解決する\code(`lazy_static!`);マクロを提供してくれる。
          lazy staticを使うと、staticな変数を、初めてアクセスがあったときに任意の非定数式で初期化できるようになる。
          IDTやGDTのようなプロセッサ構造体の定義に、lazy staticは多用することになる。
        }
        +p {
          さて、準備は完了した。VGAへのプリント機能を提供する、\code(`vga_buffer.rs`);をかきあげよう。
          \d-code(`
            #[allow(dead_code)]
            #[derive(Debug, Clone, Copy, PartialEq, Eq)]
            #[repr(u8)]
            pub enum Color {
                Black = 0,
                Blue = 1,
                Green = 2,
                Cyan = 3,
                Red = 4,
                Magenta = 5,
                Brown = 6,
                LightGray = 7,
                DarkGray = 8,
                LightBlue = 9,
                LightGreen = 10,
                LightCyan = 11,
                LightRed = 12,
                Pink = 13,
                Yellow = 14,
                White = 15,
            }
          `);
          Color enumを定義する。Debugをderiveするだけで、のちのちデバッグプリントができるようになる。
          このまま一気に完成形まで進めてしまおう。
          \d-code(`
            use volatile::Volatile;
            use core::fmt;
            use lazy_static::lazy_static;
            use spin::Mutex;

            #[derive(Debug, Clone, Copy, PartialEq, Eq)]
            #[repr(transparent)]
            struct ColorCode(u8);

            impl ColorCode {
                fn new(foreground: Color, background: Color) -> ColorCode {
                    ColorCode((background as u8) << 4 | (foreground as u8))
                }
            }

            #[derive(Debug, Clone, Copy, PartialEq, Eq)]
            #[repr(C)]
            struct ScreenChar {
                ascii_character: u8,
                color_code: ColorCode,
            }
            
            const BUFFER_HEIGHT: usize = 25;
            const BUFFER_WIDTH: usize = 80;
            
            #[repr(transparent)]
            struct Buffer {
                chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],
            }

            pub struct Writer {
              column_position: usize,
              color_code: ColorCode,
              buffer: &'static mut Buffer,
            }

            lazy_static! {
                pub static ref WRITER: Mutex<Writer> = Mutex::new(Writer {
                    column_position: 0,
                    color_code: ColorCode::new(Color::Yellow, Color::Black),
                    buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },
                });
            }

            impl Writer {
                pub fn write_string(&mut self, s: &str) {
                    for byte in s.bytes() {
                        match byte {
                            0x20...0x7e | b'\n' => self.write_byte(byte),
                            _ => self.write_byte(0xfe),
                        }
                    }
                }

                pub fn write_byte(&mut self, byte: u8) {
                    match byte {
                        b'\n' => self.new_line(),
                        byte => {
                            if self.column_position >= BUFFER_WIDTH {
                                self.new_line();
                            }

                            let row = BUFFER_HEIGHT - 1;
                            let col = self.column_position;

                            let color_code = self.color_code;
                            self.buffer.chars[row][col].write(ScreenChar {
                                ascii_character: byte,
                                color_code,
                            });
                            self.column_position += 1;
                        }
                    }
                }

                fn new_line(&mut self) {
                    for row in 1..BUFFER_HEIGHT {
                        for col in 0..BUFFER_WIDTH {
                            let character = self.buffer.chars[row][col].read();
                            self.buffer.chars[row - 1][col].write(character);
                        }
                    }
                    self.clear_row(BUFFER_HEIGHT - 1);
                    self.column_position = 0;
                }

                fn clear_row(&mut self, row: usize) {
                    let blank = ScreenChar {
                        ascii_character: b' ',
                        color_code: self.color_code,
                    };
                    for col in 0..BUFFER_WIDTH {
                        self.buffer.chars[row][col].write(blank);
                    }
                }
            }

            impl fmt::Write for Writer {
                fn write_str(&mut self, s: &str) -> fmt::Result {
                    self.write_string(s);
                    Ok(())
                }
            }    
            
          `);

          これにさらに、\code(`println!`);マクロを、標準ライブラリからまねしながらコピーしてくる。

          \d-code(`
            #[macro_export]
            macro_rules! print {
                ($($arg:tt)*) => ($crate::vga_buffer::_print(format_args!($($arg)*)));
            }

            #[macro_export]
            macro_rules! println {
                () => ($crate::print!("\n"));
                ($($arg:tt)*) => ($crate::print!("{}\n", format_args!($($arg)*)));
            }

            #[doc(hidden)]
            pub fn _print(args: fmt::Arguments) {
                use core::fmt::Write;
                WRITER.lock().write_fmt(args).unwrap();
            }
          `);
          
          これで完成だ！するとmain.rsで、次みたいなことができる。

          \d-code(`
            pub mod vga_buffer;

            #[no_mangle]
            pub extern "C" fn _start() -> ! {
                println!("Hello Hello, World!\nsome numbers: {} {}", 42, 1.337);

                loop {}
            }
          `);

          注目してほしいのは、もうフォーマットが動いていることだ。
          printfにあたるものがこんなにスムーズに使えるのはすごい。
          これをビルドして起動すると、無事に\ref-figure(`fig:println`);のように、Qemuの画面上に新たなHello, World!が表示された。

          \figure ?:(`fig:println`)
            {Hello World 2}
            <+image-frame{\insert-image(14cm)(`../pohe/figure/println.JPG`);}>
        }
      >
    >

    +subsection{No Magic with Multiboot Header} <
      +p {
        さて、先ほどまではPhilipp'sの2nd editionに基づいてRustでカーネルを書いてきた。
        Philipp氏が用意してきたCrateの手軽さもあいまって、
        あまりベアメタルプログラミングらしいことをせずともあれよあれよという間にHello, World!が無事画面に躍り出ることになった。
        でも、正直に言おう。ちょっとこれじゃ高級すぎてよくわからない！
        込み入ったことをしてくると、リンカスクリプトを書いたりブートプロセスを工夫したりするシーンがすぐにやってくるだろうから、
        もう少し、地に足のついた方法でブートについては試したい。
        また、bootimage + bootloaderは、マイクロカーネル方式と相性が悪いという現実的な問題もある。
        Multibootの説明の際に話したように、マイクロカーネルではブートローダーに複数の独立したバイナリモジュールをメモリ空間に読み込んでもらう必要があるからだ。
        そういうわけで、古き良きMultiboot Headerをスクラッチでアセンブリで書いていこう。
        その後、自分で書いたスタックやレジスタの初期化、それにロングモードへのジャンプなんかと合わせてと、Rustで書いたバイナリとリンクしていくことにする。
      }
      +p {
        ...
      }
      +p {
        ...
      }
      +p {
        ...
      }
      +p {
        ...
      }
    >

    +subsection{Welcome} <
      +code(`
        　　　　∧＿∧　やあ
        　　　（´・ω・｀)　　　　　　/　　　　　　　ようこそ、バーボンハウスへ。 
        　　／∇y:::::::＼　　　[￣￣]　　　　　　このテキーラはサービスだから、まず飲んで落ち着いて欲しい。
        　　|:::⊃:|:::::|　　　|──|　　　　　　
        ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|　うん、「未完」なんだ。済まない。だいたいここで尻切れトンボに
        ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|￣　なってる。仏の顔もって言うしね、謝って許してもらおうとも思ってない。
        ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|
        　　　　∇　∇　∇　∇　　　|　　　でも、この記事の目次を見たとき、君は、きっと言葉では
        　　　　┴　┴　┴　┴　　　|　　　言い表せない「ときめき」みたいなものを感じてくれたと思う。 
        ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|　　　殺伐とした世の中で、そういう気持ちを忘れないで欲しい 
        ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|　　　そう思って、この記事を書いたんだ。
        　　　　　　　　　　　　　　　|
        　　　　　　　　　　　　　　　|　　　じゃあ、注文を聞こうか。
      `);
      
      +subsubsection {nullpo_headはどうして締め切りに間に合わない？原因は？対策は？調べてみました！} <
        +p {
          はい、ここで締め切りです。いかがでしたか？
          いよいよ本番始まったな？ってところで尻切れトンボになったら「いかがでしたか？」もくそもないですね。
          とても反省しています。ちなみに原因と対策を考えると「仕事を辞める」が最善策になります。平日何もできなさすぎる。
        }
        +p {
          一応、この記事では、導入部分とPhilippさんのcrateを使いまくったうえでのRustでのカーネル開発の導入までは完結しました。
          これ以降はヤバイテックトーキョーの次号連載をお楽しみにしてください。
          この後は、上にちらっと書いてあるように、Multibootを使って、static libraryとしてビルドしたカーネルと色々リンクさせて頑張っていく感じになります。
          記事が完成しなかったので先にいうとスタックは深く初期化しておけ、Rustはデバッグビルドだとlazy_staticともあわさってアホ程スタック食う。
          何かの役に立つかもしれないから、以降の続きの筋書も、予告編としてメモ書き程度に残しておきます。
          また、コード自体はもう少し先まで進んでいるので、解説は間に合っていませんが、参考にはできるかもしれません。
          https://github.com/nullpo-head/rusty-l4 なので、生暖かく見守りたい人はwatchでもしといてください。
          ところでこの連載記事は、Webで公開するときは、勝手に英語になってくれてたらうれしいなという願望があります。
          Peddle OS (https://pebble-os.github.io/) とかいうもろかぶりネタが進行中ですし。
          そんなことを考えていたら本文をなんとなく翻訳調の文章で書いてみたくなった感じです。このノリの源流ってどこなんでしょうね。
        }
        +p {
          そんなわけで、2日目の途中で今回での記事は終了ですが、次回の連載を楽しみにしてくれたら幸いです。
          いかがでしたか？以降、次号の予告編です。
        }
      >
    >

    +subsection{予告編} <
      +listing{

        * multibootヘッダーを書こう
        * まず、startup.Sを書いて、Qemuのシリアル機能を使って無事'A'という文字を出力！無事ブートできたみたいだ。
        * 急になるが環境を一気に用意する
        * リンカスクリプトを書こう
        * multiboot v1に別れを告げる
        * grub2用の起動ディスクを用意
        * WSL上だと（というかおそらく実際にgrubで起動していない環境だと）grub-mkrescueでうまくブートデバイスが作れない。
          \code(`grub-pc-bin`);をインストールするとうまくブータブルISOが作られるようになる。
           See https://github.com/Microsoft/WSL/issues/807

        * ロングモードまで入ってさっさとRustの世界に帰ることにしよう。

        * 個人的にはこの部分を書くのがいつも一番面倒だ！1GBページとGDTをさっさと用意してしまおう
         
        * Rustとは関係ない、Multibootの部分で随分と苦労したが、Philippの高級なcrateを使ってブートした時と同じHello, Worldを無事表示できた。
          これでRusty L4の最小カーネルは完成だ！
      }
    >
  >

    +section{予告編\; 3rd Day: Write a Microkernel Server for L4 Pistachio} <
      +p {
        さて、この挑戦も今日も3日目だ。
        もっとも、開発をし終わったあとにこの文章を編集して、こまぎれの記録を一つにまとめて皆さんにはお見せしているから、
        私としては実際にはだいぶ日数が経っているのだけど。
        ともあれ、昨日で私は、Rustでのベアメタルプログラミングの世界を体験してきた。
        最終的には、Qemuの画面上に、無事に"Hello, World!"を表示できたわけだ。
        ベアメタルプログラミングをしているにもかかわらず、Cでの開発のときと違い、crateを使って簡単にブートができてしまったことや、
        \code(`println!`);マクロが使えるまでの道のりの簡単さは本当に驚異的だった。
        ベアメタルプログラミングをやっているにもかかわらず、Traitなんていう普段Web開発をしているときに使うような高級な概念を普通に使える感覚も新鮮だ。
        Rustはベアメタルプログラミングをもっと簡単に、そして楽しくしてくれそうだというのは間違いない。
      }
      +p {
        おっと！Rustに関する話に少し脱線してしまったようだ。
        そろそろ今日、3日目にやることについて話そう。
        今日は一旦フルスクラッチのベアメタルプログラミングの世界から離れて、L4マイクロカーネル上での世界に戻ってみる。
        まずは、VGAのメモリ領域をたたいて、Hello, World!と表示させるだけのサーバーから始めよう。
        明日以降、これを自分で書いたカーネルの上で走らせることを目標とするためだ。
        今回書こうとしているサーバーは、1番目に起動することを想定する特殊なサーバーであることには留意してほしい。
        多分普通にサーバーを書く分にはもっと苦労しないはずだ。
        今回のこの作業を通して、一般にCPU上でOSのカーネルがメモリ空間をどう管理するかについても触れるかもしれない。
      }
    >

  >
>
